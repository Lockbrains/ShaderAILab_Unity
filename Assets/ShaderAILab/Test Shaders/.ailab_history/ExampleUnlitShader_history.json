{
    "snapshots": [
        {
            "Id": "b547dd88",
            "Description": "Before compile",
            "Content": "Shader \"AILab/ExampleUnlitShader\" {\n    Properties {\n        // [AILab_Property: name=\"_BaseColor\" display=\"Base Color\" type=\"Color\" default=\"(1,1,1,1)\"]\n        _BaseColor(\"Base Color\", Color) = (1,1,1,1)\n        // [AILab_Property: name=\"_Brightness\" display=\"Brightness\" type=\"Range\" default=\"1\" min=\"0\" max=\"2\"]\n        _Brightness(\"Brightness\", Range(0,2)) = 1\n        // [AILab_Property: name=\"_BaseMap\" display=\"基础颜色贴图\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _BaseMap(\"基础颜色贴图\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_Hatching_Layer1\" display=\"第一层排线属性 (浅阴影)\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _Hatching_Layer1(\"第一层排线属性 (浅阴影)\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_Hatching_Layer2\" display=\"第二层排线属性 (深阴影交叉)\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _Hatching_Layer2(\"第二层排线属性 (深阴影交叉)\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_ShadowDepthThresholds\" display=\"阴影深度分级阈值\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _ShadowDepthThresholds(\"阴影深度分级阈值\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_OutlineWidth\" display=\"Outline Width\" type=\"Range\" default=\"0.015\" min=\"0\" max=\"0.1\"]\n        _OutlineWidth(\"Outline Width\", Range(0, 0.1)) = 0.015\n        // [AILab_Property: name=\"_OutlineColor\" display=\"Outline Color\" type=\"Color\" default=\"(0,0,0,1)\"]\n        _OutlineColor(\"Outline Color\", Color) = (0, 0, 0, 1)\n        // [AILab_Property: name=\"_ShadowThreshold\" display=\"Shadow Threshold\" type=\"Range\" default=\"0.0\" min=\"-1\" max=\"1\"]\n        _ShadowThreshold(\"Shadow Threshold\", Range(-1, 1)) = 0.0\n        // [AILab_Property: name=\"_HatchTex\" display=\"Hatching Texture\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _HatchTex(\"Hatching Texture\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_HatchScale\" display=\"Hatching Scale\" type=\"Range\" default=\"10.0\" min=\"1\" max=\"50\"]\n        _HatchScale(\"Hatching Scale\", Range(1, 50)) = 10.0\n        // [AILab_Property: name=\"_ScreenHatchParams\" display=\"屏幕空间浅阴影排线参数 (Screen Space Hatching)\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _ScreenHatchParams(\"屏幕空间浅阴影排线参数 (Screen Space Hatching)\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_ScreenCrossHatchParams\" display=\"屏幕空间深阴影交叉排线 (Screen Space Cross-Hatching)\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _ScreenCrossHatchParams(\"屏幕空间深阴影交叉排线 (Screen Space Cross-Hatching)\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_LightingThresholds\" display=\"光照阶梯化阈值 (Procedural Ramp Thresholds)\" type=\"Texture2D\" default=\"\" defaultTex=\"white\"]\n        _LightingThresholds(\"光照阶梯化阈值 (Procedural Ramp Thresholds)\", 2D) = \"white\" {}\n        // [AILab_Property: name=\"_ShadowSmoothing\" display=\"Shadow Smoothing\" type=\"Range\" default=\"0.05\" min=\"0.001\" max=\"0.5\"]\n        _ShadowSmoothing(\"Shadow Smoothing\", Range(0.001, 0.5)) = 0.05\n        // [AILab_Property: name=\"_DeepShadowThreshold\" display=\"Deep Shadow Threshold\" type=\"Range\" default=\"0.1\" min=\"0\" max=\"1\"]\n        _DeepShadowThreshold(\"Deep Shadow Threshold\", Range(0, 1)) = 0.1\n    }\n    SubShader {\n        // [AILab_Global: cull=\"Back\" blend=\"Off\" zwrite=\"On\"]\n        Tags { \"RenderType\"=\"Tags\" \"Queue\"=\"Geometry\" \"RenderPipeline\"=\"UniversalPipeline\" }\n        Cull Back\n        ZWrite On\n\n        // [AILab_Pass: name=\"ForwardUnlit\" lightmode=\"UniversalForward\"]\n        Pass {\n            Name \"ForwardUnlit\"\n            Tags { \"LightMode\"=\"UniversalForward\" }\n\n            ZWrite 开启深度写入确保正确的遮挡关系。\n\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile_fog\n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n\n            TEXTURE2D(_BaseMap); SAMPLER(sampler_BaseMap);\n            TEXTURE2D(_Hatching_Layer1); SAMPLER(sampler_Hatching_Layer1);\n            TEXTURE2D(_Hatching_Layer2); SAMPLER(sampler_Hatching_Layer2);\n            TEXTURE2D(_ShadowDepthThresholds); SAMPLER(sampler_ShadowDepthThresholds);\n            TEXTURE2D(_HatchTex); SAMPLER(sampler_HatchTex);\n            TEXTURE2D(_ScreenHatchParams); SAMPLER(sampler_ScreenHatchParams);\n            TEXTURE2D(_ScreenCrossHatchParams); SAMPLER(sampler_ScreenCrossHatchParams);\n            TEXTURE2D(_LightingThresholds); SAMPLER(sampler_LightingThresholds);\n\n            CBUFFER_START(UnityPerMaterial)\n                float4 _BaseColor;\n                float _Brightness;\n                float4 _BaseMap_ST;\n                float4 _Hatching_Layer1_ST;\n                float4 _Hatching_Layer2_ST;\n                float4 _ShadowDepthThresholds_ST;\n                float _OutlineWidth;\n                float4 _OutlineColor;\n                float _ShadowThreshold;\n                float4 _HatchTex_ST;\n                float _HatchScale;\n                float4 _ScreenHatchParams_ST;\n                float4 _ScreenCrossHatchParams_ST;\n                float4 _LightingThresholds_ST;\n                float _ShadowSmoothing;\n                float _DeepShadowThreshold;\n            CBUFFER_END\n\n            struct Attributes {\n                float4 positionOS  : POSITION;\n                float3 normalOS    : NORMAL;\n                float2 uv          : TEXCOORD0;\n            };\n\n            struct Varyings {\n                float4 positionCS  : SV_POSITION;\n                float3 normalWS    : TEXCOORD0;\n                float2 uv          : TEXCOORD1;\n                float3 positionWS  : TEXCOORD2;\n                float fogFactor    : TEXCOORD3;\n                float4 screenPos   : TEXCOORD4;\n            };\n\n            // [AILab_Section: \"Helper Functions\"]\n            // [AILab_Block_Start: \"Moebius Stylized Shading\"]\n            // [AILab_Intent: \"Evaluate stepped lighting and apply screen-space procedural hatching based on shadow intensity\"]\n            // [AILab_Param: \"_ShadowThreshold\" role=\"parameter\"]\n            // [AILab_Param: \"_ShadowSmoothing\" role=\"parameter\"]\n            // [AILab_Param: \"_DeepShadowThreshold\" role=\"parameter\"]\n            // [AILab_Param: \"_HatchScale\" role=\"parameter\"]\n            // [AILab_Param: \"_Hatching_Layer1\" role=\"parameter\"]\n            // [AILab_Param: \"_Hatching_Layer2\" role=\"parameter\"]\n            half3 ApplyMoebiusShading(Varyings input, half3 albedo) {\n                // 1. Get URP Main Light & Real-time Shadow\n                float4 shadowCoord = TransformWorldToShadowCoord(input.positionWS);\n                Light mainLight = GetMainLight(shadowCoord);\n                \n                // 2. Calculate Diffuse Intensity\n                half NdotL = saturate(dot(normalize(input.normalWS), mainLight.direction));\n                half attenuation = mainLight.shadowAttenuation * mainLight.distanceAttenuation;\n                half diffuseIntensity = NdotL * attenuation;\n                \n                // 3. Stepped Lighting Masks (Binary/Tertiary Masking)\n                half lightMask = smoothstep(_ShadowThreshold - _ShadowSmoothing, _ShadowThreshold + _ShadowSmoothing, diffuseIntensity);\n                half darkMask = smoothstep(_DeepShadowThreshold - _ShadowSmoothing, _DeepShadowThreshold + _ShadowSmoothing, diffuseIntensity);\n                \n                // 4. Screen-Space UV Calculation (Aspect Ratio Corrected)\n                float2 screenUV = input.screenPos.xy / max(input.screenPos.w, 0.001);\n                screenUV.x *= _ScreenParams.x / _ScreenParams.y;\n                screenUV *= _HatchScale * 10.0; // Scaled to reasonable stroke density\n                \n                // 5. Sample Hatching Textures\n                half hatch1 = SAMPLE_TEXTURE2D(_Hatching_Layer1, sampler_Hatching_Layer1, screenUV).r;\n                half hatch2 = SAMPLE_TEXTURE2D(_Hatching_Layer2, sampler_Hatching_Layer2, screenUV).r;\n                \n                // 6. Combine Cross-Hatching based on Shadow Depth\n                // Darkest regions get cross-hatching (Layer1 * Layer2)\n                // Mid-shadows get single hatching (Layer1)\n                // Light regions get no hatching (1.0)\n                half midHatch = hatch1;\n                half deepHatch = hatch1 * hatch2;\n                \n                half hatchIntensity = lerp(deepHatch, midHatch, darkMask);\n                hatchIntensity = lerp(hatchIntensity, 1.0, lightMask);\n                \n                // 7. Base Color Cel Shading\n                half3 lightColor = albedo * mainLight.color;\n                half3 shadowColor = albedo * mainLight.color * 0.5; // Tint albedo for unlit regions\n                half3 celShadedColor = lerp(shadowColor, lightColor, lightMask);\n                \n                // 8. Multiply Inked Hatching to the Shaded Color\n                return celShadedColor * hatchIntensity;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Section: \"Vertex\"]\n            // [AILab_Block_Start: \"Main Vertex\"]\n            // [AILab_Intent: \"Pass-through for vertex position, standard transform handled by framework\"]\n            void MainVertex(inout float3 posOS) {\n                // No specific vertex displacement needed for the main stylized pass\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Outline Extrusion\"]\n            // [AILab_Intent: \"Extrude vertices along normalized position to simulate thick ink outline\"]\n            // [AILab_Param: \"_OutlineWidth\" role=\"parameter\"]\n            void ExtrudeOutline(inout float3 posOS) {\n                // Inverted hull: extruding along an approximated normal\n                float3 normalProxy = normalize(posOS);\n                posOS += normalProxy * _OutlineWidth;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Shadow Caster Vertex\"]\n            // [AILab_Intent: \"Pass-through for standard shadow mapping\"]\n            void ShadowVertex(inout float3 posOS) {\n                // Framework handles URP's shadow bias positioning automatically\n            }\n            // [AILab_Block_End]\n\n            Varyings vert(Attributes input) {\n                Varyings output = (Varyings)0;\n                float3 posOS = input.positionOS.xyz;\n                MainVertex(posOS);\n                ExtrudeOutline(posOS);\n                ShadowVertex(posOS);\n                VertexPositionInputs vpi = GetVertexPositionInputs(posOS);\n                VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS);\n                output.positionCS = vpi.positionCS;\n                output.normalWS = vni.normalWS;\n                output.uv = input.uv;\n                output.positionWS = vpi.positionWS;\n                output.fogFactor = ComputeFogFactor(vpi.positionCS.z);\n                output.screenPos = ComputeScreenPos(vpi.positionCS);\n                return output;\n            }\n\n            // [AILab_Section: \"Fragment\"]\n            // [AILab_Block_Start: \"Moebius Fragment\"]\n            // [AILab_Intent: \"Sample base color and execute Moebius screen-space hatching\"]\n            // [AILab_Param: \"_BaseMap\" role=\"parameter\"]\n            // [AILab_Param: \"_BaseColor\" role=\"parameter\"]\n            half4 MoebiusFragment(Varyings input) {\n                float2 uv = input.uv * _BaseMap_ST.xy + _BaseMap_ST.zw;\n                half4 texColor = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv);\n                half4 baseColor = texColor * _BaseColor;\n                \n                half3 finalRGB = ApplyMoebiusShading(input, baseColor.rgb);\n                \n                return half4(finalRGB, baseColor.a);\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Outline Color\"]\n            // [AILab_Intent: \"Return solid color for the ink contour\"]\n            // [AILab_Param: \"_OutlineColor\" role=\"parameter\"]\n            half4 OutlineColor(Varyings input) {\n                return _OutlineColor;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Shadow Caster Fragment\"]\n            // [AILab_Intent: \"Empty return as depth map generation relies solely on depth test\"]\n            half4 ShadowFragment(Varyings input) {\n                return half4(0, 0, 0, 0);\n            }\n            // [AILab_Block_End]\n\n            half4 frag(Varyings input) : SV_Target {\n                half4 finalColor = half4(1,1,1,1);\n                finalColor = MoebiusFragment(input);\n                finalColor = OutlineColor(input);\n                finalColor = ShadowFragment(input);\n                return finalColor;\n            }\n\n            ENDHLSL\n        }\n\n        // [AILab_Pass: name=\"DepthOnly\" lightmode=\"DepthOnly\"]\n        Pass {\n            Name \"DepthOnly\"\n            Tags { \"LightMode\"=\"DepthOnly\" }\n\n            Cull Back\n            ZWrite On\n            ZTest LEqual\n            ColorMask 0\n\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n\n            TEXTURE2D(_BaseMap); SAMPLER(sampler_BaseMap);\n            TEXTURE2D(_Hatching_Layer1); SAMPLER(sampler_Hatching_Layer1);\n            TEXTURE2D(_Hatching_Layer2); SAMPLER(sampler_Hatching_Layer2);\n            TEXTURE2D(_ShadowDepthThresholds); SAMPLER(sampler_ShadowDepthThresholds);\n            TEXTURE2D(_HatchTex); SAMPLER(sampler_HatchTex);\n            TEXTURE2D(_ScreenHatchParams); SAMPLER(sampler_ScreenHatchParams);\n            TEXTURE2D(_ScreenCrossHatchParams); SAMPLER(sampler_ScreenCrossHatchParams);\n            TEXTURE2D(_LightingThresholds); SAMPLER(sampler_LightingThresholds);\n\n            CBUFFER_START(UnityPerMaterial)\n                float4 _BaseColor;\n                float _Brightness;\n                float4 _BaseMap_ST;\n                float4 _Hatching_Layer1_ST;\n                float4 _Hatching_Layer2_ST;\n                float4 _ShadowDepthThresholds_ST;\n                float _OutlineWidth;\n                float4 _OutlineColor;\n                float _ShadowThreshold;\n                float4 _HatchTex_ST;\n                float _HatchScale;\n                float4 _ScreenHatchParams_ST;\n                float4 _ScreenCrossHatchParams_ST;\n                float4 _LightingThresholds_ST;\n                float _ShadowSmoothing;\n                float _DeepShadowThreshold;\n            CBUFFER_END\n\n            struct Attributes {\n                float4 positionOS  : POSITION;\n            };\n\n            struct Varyings {\n                float4 positionCS  : SV_POSITION;\n            };\n\n            // [AILab_Section: \"Vertex\"]\n            // [AILab_Block_Start: \"Outline Extrusion\"]\n            // [AILab_Intent: \"Extrude vertices along object-space normals to create an inverted hull outline.\"]\n            // [AILab_Param: \"_OutlineWidth\" role=\"parameter\"]\n            void ExtrudeOutline(inout float3 positionOS) {\n                // Extrude vertex position along the normal. \n                // The auto-generated framework provides 'input' from which we read normalOS.\n                positionOS += input.normalOS * _OutlineWidth;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Shadow Caster Vertex\"]\n            // [AILab_Intent: \"Vertex shader pass-through for the URP shadow caster pass.\"]\n            void ShadowCasterVertex(inout float3 positionOS) {\n                // The framework handles the standard URP ShadowCaster position and normal bias transformations.\n                // We simply act as a pass-through for the base object space position here.\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Depth Only Vertex\"]\n            // [AILab_Intent: \"Vertex shader pass-through for the URP Depth pre-pass.\"]\n            void DepthOnlyVertex(inout float3 positionOS) {\n                // The framework auto-generates the transformation from object space to clip space.\n            }\n            // [AILab_Block_End]\n\n            Varyings vert(Attributes input) {\n                Varyings output = (Varyings)0;\n                float3 posOS = input.positionOS.xyz;\n                ExtrudeOutline(posOS);\n                ShadowCasterVertex(posOS);\n                DepthOnlyVertex(posOS);\n                VertexPositionInputs vpi = GetVertexPositionInputs(posOS);\n                output.positionCS = vpi.positionCS;\n                return output;\n            }\n\n            // [AILab_Section: \"Fragment\"]\n            // [AILab_Block_Start: \"Outline Color Output\"]\n            // [AILab_Intent: \"Return the solid ink outline color for the extruded hull.\"]\n            // [AILab_Param: \"_OutlineColor\" role=\"parameter\"]\n            half4 OutlineColorOutput(Varyings input) {\n                return _OutlineColor;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Shadow Caster Fragment\"]\n            // [AILab_Intent: \"Output an empty color since the shadow caster only cares about writing to the depth map.\"]\n            half4 ShadowCasterFragment(Varyings input) {\n                return 0;\n            }\n            // [AILab_Block_End]\n\n            // [AILab_Block_Start: \"Depth Only Fragment\"]\n            // [AILab_Intent: \"Output an empty color. ColorMask is 0, so only the depth buffer is updated.\"]\n            half4 DepthOnlyFragment(Varyings input) {\n                return 0;\n            }\n            // [AILab_Block_End]\n\n            half4 frag(Varyings input) : SV_Target {\n                half4 finalColor = half4(1,1,1,1);\n                finalColor = OutlineColorOutput(input);\n                finalColor = ShadowCasterFragment(input);\n                finalColor = DepthOnlyFragment(input);\n                return finalColor;\n            }\n\n            ENDHLSL\n        }\n\n    }\n    FallBack \"Hidden/Universal Render Pipeline/FallbackError\"\n    CustomEditor \"ShaderAILab.Editor.ShaderAILabGUI\"\n}\n"
        }
    ]
}