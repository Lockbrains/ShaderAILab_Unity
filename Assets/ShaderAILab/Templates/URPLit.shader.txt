Shader "AILab/Template" {
    Properties {
        // [AILab_Property: name="_BaseColor" display="Base Color" type="Color" default="(1,1,1,1)"]
        _BaseColor("Base Color", Color) = (1,1,1,1)
        // [AILab_Property: name="_Smoothness" display="Smoothness" type="Range" min="0" max="1" default="0.5"]
        _Smoothness("Smoothness", Range(0,1)) = 0.5
        // [AILab_Property: name="_Metallic" display="Metallic" type="Range" min="0" max="1" default="0"]
        _Metallic("Metallic", Range(0,1)) = 0
        // [AILab_Property: name="_MainTex" display="Base Map" type="Texture2D" default="white"]
        _MainTex("Base Map", 2D) = "white" {}
    }
    SubShader {
        // [AILab_Global: cull="Back" blend="Off" zwrite="On"]
        Tags { "RenderType"="Opaque" "Queue"="Geometry" "RenderPipeline"="UniversalPipeline" }
        Cull Back
        ZWrite On

        // [AILab_Pass: name="ForwardLit" lightmode="UniversalForward"]
        Pass {
            Name "ForwardLit"
            Tags { "LightMode"="UniversalForward" }

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _ _ADDITIONAL_LIGHTS
            #pragma multi_compile_fragment _ _SHADOWS_SOFT
            #pragma multi_compile_fog

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

            TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex);

            CBUFFER_START(UnityPerMaterial)
                float4 _BaseColor;
                float4 _MainTex_ST;
                float _Smoothness;
                float _Metallic;
            CBUFFER_END

            struct Attributes {
                float4 positionOS : POSITION;
                float3 normalOS   : NORMAL;
                float2 uv         : TEXCOORD0;
            };

            struct Varyings {
                float4 positionCS           : SV_POSITION;
                float3 normalWS             : TEXCOORD0;
                float2 uv                   : TEXCOORD1;
                float3 positionWS           : TEXCOORD2;
                float  fogFactor            : TEXCOORD3;
                float4 shadowCoord          : TEXCOORD4;
            };

            // [AILab_Section: "Helper Functions"]

            // [AILab_Section: "Vertex"]
            // [AILab_Block_Start: "Standard Vertex Transform"]
            // [AILab_Intent: "Transform vertex to clip space with world-space normal and position"]
            // Standard URP vertex transformation, no custom displacement.
            // [AILab_Block_End]

            Varyings vert(Attributes input) {
                Varyings output = (Varyings)0;
                VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
                VertexNormalInputs   vni = GetVertexNormalInputs(input.normalOS);
                output.positionCS = vpi.positionCS;
                output.positionWS = vpi.positionWS;
                output.normalWS   = vni.normalWS;
                output.uv         = TRANSFORM_TEX(input.uv, _MainTex);
                output.fogFactor  = ComputeFogFactor(vpi.positionCS.z);
                output.shadowCoord = GetShadowCoord(vpi);
                return output;
            }

            // [AILab_Section: "Fragment"]
            // [AILab_Block_Start: "PBR Lighting"]
            // [AILab_Intent: "Calculate simple PBR lighting using URP main light"]
            // [AILab_Param: "_BaseColor" role="albedo_tint"]
            // [AILab_Param: "_Smoothness" role="surface_smoothness"]
            // [AILab_Param: "_Metallic" role="metallic_amount"]
            half4 ComputeLighting(Varyings input) {
                half4 texColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv);
                half4 albedo = texColor * _BaseColor;

                InputData inputData = (InputData)0;
                inputData.positionWS = input.positionWS;
                inputData.normalWS = normalize(input.normalWS);
                inputData.viewDirectionWS = GetWorldSpaceNormalizeViewDir(input.positionWS);
                inputData.shadowCoord = input.shadowCoord;
                inputData.fogCoord = InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactor);
                inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(input.positionCS);
                inputData.bakedGI = half3(0, 0, 0);

                SurfaceData surfaceData = (SurfaceData)0;
                surfaceData.albedo = albedo.rgb;
                surfaceData.metallic = _Metallic;
                surfaceData.smoothness = _Smoothness;
                surfaceData.normalTS = half3(0, 0, 1);
                surfaceData.emission = half3(0, 0, 0);
                surfaceData.occlusion = 1.0;
                surfaceData.alpha = albedo.a;
                surfaceData.specular = half3(0, 0, 0);
                surfaceData.clearCoatMask = 0;
                surfaceData.clearCoatSmoothness = 0;

                half4 color = UniversalFragmentPBR(inputData, surfaceData);
                color.rgb = MixFog(color.rgb, input.fogFactor);
                return color;
            }
            // [AILab_Block_End]

            half4 frag(Varyings input) : SV_Target {
                return ComputeLighting(input);
            }

            ENDHLSL
        }

        UsePass "Universal Render Pipeline/Lit/ShadowCaster"
        UsePass "Universal Render Pipeline/Lit/DepthOnly"
    }
    FallBack "Hidden/Universal Render Pipeline/FallbackError"
}
