using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using ShaderAILab.Editor.Core;

namespace ShaderAILab.Editor.LLM
{
    /// <summary>
    /// Constructs system and user prompts tailored for shader generation.
    /// Handles both global (auto-place) and targeted (specific block/section) modes.
    /// </summary>
    public static class PromptTemplates
    {
        const string CoreSystemPrompt = @"You are an expert HLSL shader programmer for Unity's Universal Render Pipeline (URP).

RULES:
1. Output ONLY valid HLSL code. No markdown, no explanations outside code comments.
2. Use URP conventions: CBUFFER_START/END, TEXTURE2D/SAMPLER macros, Packages/com.unity.render-pipelines.universal/ShaderLibrary includes.
3. Write self-contained functions. Each function should have clear inputs and outputs.
4. Always expose tunable parameters as shader properties. For any magic number that affects visual appearance, create a property with a sensible Range.
5. Use float/half types appropriately (half for colors and normalized values, float for positions).
6. Include AILab metadata tags in your output:
   - Wrap each logical function with: // [AILab_Block_Start: ""<Title>""] and // [AILab_Block_End]
   - The <Title> MUST be a SHORT English name (2-5 words, like ""PBR Lighting"", ""Toon Shading"", ""Rim Light Effect""). Do NOT use the user's prompt as the title.
   - Add intent: // [AILab_Intent: ""<description>""]
   - Reference parameters: // [AILab_Param: ""_ParamName"" role=""<role>""]
   - Declare properties: // [AILab_Property: name=""_Name"" display=""Display Name"" type=""Range"" min=""0"" max=""1"" default=""0.5""]
7. If generating a property, include BOTH the AILab_Property tag AND the Unity property declaration line.
   Place ALL property tags BEFORE the block code, NOT inside the function body.
8. Code must compile without errors in URP.
9. IMPORTANT: Your function must ONLY reference properties that already exist in the shader OR that you declare with AILab_Property tags.
   Do NOT reference undeclared variables. Every variable used in the function body must either be:
   (a) declared as a function parameter, (b) a local variable, (c) a property you declared with AILab_Property,
   (d) a field from the Varyings/Attributes struct, or (e) a URP built-in.
10. Fragment functions should have signature: half4 FuncName(Varyings input) { ... }
    Vertex functions should have signature: void FuncName(inout float3 posOS) { ... }
    Helper functions can have any signature.
11. NEVER generate CBUFFER_START/CBUFFER_END blocks, struct Attributes, struct Varyings, or variable declaration blocks.
    These are auto-generated by the system from the properties you declare with AILab_Property tags.
    Your code should ONLY contain function definitions wrapped in AILab_Block_Start/End tags, plus AILab_Property tags for any new properties.
12. Do NOT create blocks whose sole purpose is declaring variables or properties. Only create function blocks.";

        // ---- System Prompt ----

        public static string BuildSystemPrompt(ShaderDocument doc, string targetContext)
        {
            var sb = new StringBuilder(CoreSystemPrompt);

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Existing blocks: {FormatBlocks(doc)}");
                sb.AppendLine($"- Render settings: Cull={doc.GlobalSettings.CullMode}, Blend={doc.GlobalSettings.BlendMode}, ZWrite={doc.GlobalSettings.ZWriteMode}");
                sb.AppendLine($"- Active Attributes fields: {FormatActiveFields(doc.DataFlow, DataFlowStage.Attributes)}");
                sb.AppendLine($"- Active Varyings fields: {FormatActiveFields(doc.DataFlow, DataFlowStage.Varyings)}");
            }

            if (!string.IsNullOrEmpty(targetContext))
            {
                sb.AppendLine();
                if (targetContext.StartsWith("Block:"))
                {
                    sb.AppendLine($"TARGET: You are editing an existing block. Replace its code completely. Keep the same function signature if possible.");
                }
                else if (targetContext.Contains("Vertex"))
                {
                    sb.AppendLine("TARGET: Generate a VERTEX shader function. It should modify vertex positions (inout float3 positionOS) or other vertex attributes.");
                }
                else if (targetContext.Contains("Fragment"))
                {
                    sb.AppendLine("TARGET: Generate a FRAGMENT shader function. It should compute and return a color (half4).");
                }
                else if (targetContext.Contains("Helper"))
                {
                    sb.AppendLine("TARGET: Generate a helper/utility function that can be called from vertex or fragment functions.");
                }
                else
                {
                    sb.AppendLine("TARGET: Auto-determine the best location (vertex, fragment, or helper) for the requested functionality.");
                }
            }

            return sb.ToString();
        }

        // ---- User Prompt ----

        public static string BuildUserPrompt(string userRequest, ShaderDocument doc, string targetContext)
        {
            var sb = new StringBuilder();

            if (targetContext != null && targetContext.StartsWith("Block:"))
            {
                string blockTitle = targetContext.Substring(7).Trim();
                var block = doc?.FindBlockByTitle(blockTitle);
                if (block != null)
                {
                    sb.AppendLine("EXISTING CODE IN THIS BLOCK:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(block.Code);
                    sb.AppendLine("```");
                    sb.AppendLine();
                    sb.AppendLine("MODIFICATION REQUEST:");
                }
            }

            sb.AppendLine(userRequest);

            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code with AILab tags. If you need new properties, include their declarations. Wrap your code in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Response Parsing ----

        static readonly Regex ReCodeBlock = new Regex(
            @"```(?:hlsl|glsl|shader|c)?\s*\n([\s\S]*?)```",
            RegexOptions.Compiled);

        static readonly Regex RePropertyTag = new Regex(
            @"//\s*\[AILab_Property:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReBlockStartTag = new Regex(
            @"//\s*\[AILab_Block_Start:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReBlockEndTag = new Regex(
            @"//\s*\[AILab_Block_End\]", RegexOptions.Compiled);

        static readonly Regex ReIntentTag = new Regex(
            @"//\s*\[AILab_Intent:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReParamTag = new Regex(
            @"//\s*\[AILab_Param:\s*""([^""]+)""\s+role=""([^""]*)""\]", RegexOptions.Compiled);

        static readonly Regex ReSectionTag = new Regex(
            @"//\s*\[AILab_Section:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReKV = new Regex(
            @"(\w+)=""([^""]*?)""", RegexOptions.Compiled);

        /// <summary>
        /// Extract clean HLSL code from an LLM response that may contain markdown formatting.
        /// </summary>
        public static string ExtractCodeFromResponse(string response)
        {
            if (string.IsNullOrEmpty(response)) return response;

            var match = ReCodeBlock.Match(response);
            if (match.Success)
                return match.Groups[1].Value.Trim();

            string trimmed = response.Trim();
            if (trimmed.StartsWith("//") || trimmed.StartsWith("void") ||
                trimmed.StartsWith("half") || trimmed.StartsWith("float") ||
                trimmed.StartsWith("struct") || trimmed.StartsWith("CBUFFER") ||
                trimmed.StartsWith("// [AILab"))
            {
                return trimmed;
            }

            return trimmed;
        }

        /// <summary>
        /// Result of parsing a full LLM response: extracted properties, blocks, and
        /// any leftover code that wasn't inside a block tag.
        /// </summary>
        public class ParsedLLMResponse
        {
            public List<ShaderProperty> Properties = new List<ShaderProperty>();
            public List<ParsedBlock> Blocks = new List<ParsedBlock>();
            public string LeftoverCode = "";
        }

        public class ParsedBlock
        {
            public string Title;
            public string Intent;
            public string Code;
            public ShaderSectionType Section;
            public List<string> ReferencedParams = new List<string>();
        }

        /// <summary>
        /// Parse the full LLM response to extract all properties, blocks with
        /// proper titles, and section information.
        /// </summary>
        public static ParsedLLMResponse ParseFullResponse(string response, ShaderSectionType defaultSection)
        {
            var result = new ParsedLLMResponse();
            string code = ExtractCodeFromResponse(response);
            if (string.IsNullOrEmpty(code)) return result;

            string[] lines = code.Split(new[] { "\r\n", "\n" }, System.StringSplitOptions.None);

            // Track which lines belong to blocks vs leftover
            bool[] consumed = new bool[lines.Length];
            ShaderSectionType currentSection = defaultSection;

            // 1) Extract properties (and their Unity declaration on the next line)
            for (int i = 0; i < lines.Length; i++)
            {
                var pm = RePropertyTag.Match(lines[i]);
                if (!pm.Success) continue;

                var prop = new ShaderProperty();
                foreach (Match kv in ReKV.Matches(pm.Groups[1].Value))
                {
                    string key = kv.Groups[1].Value.ToLowerInvariant();
                    string val = kv.Groups[2].Value;
                    switch (key)
                    {
                        case "name":    prop.Name        = val; break;
                        case "display": prop.DisplayName = val; break;
                        case "type":    prop.PropertyType = ParsePropertyType(val); break;
                        case "default": prop.DefaultValue = val; break;
                        case "min":     if (float.TryParse(val, out float mn)) prop.MinValue = mn; break;
                        case "max":     if (float.TryParse(val, out float mx)) prop.MaxValue = mx; break;
                        case "role":    prop.Role = val; break;
                    }
                }

                consumed[i] = true;

                // Check next non-empty line for raw Unity declaration
                for (int j = i + 1; j < lines.Length && j <= i + 3; j++)
                {
                    string trimmed = lines[j].Trim();
                    if (string.IsNullOrEmpty(trimmed)) continue;
                    if (trimmed.StartsWith("//")) continue;
                    // Looks like a Unity property declaration (e.g. _Foo("Bar", Float) = 0)
                    if (trimmed.StartsWith("_") && trimmed.Contains("("))
                    {
                        prop.RawDeclaration = trimmed;
                        consumed[j] = true;
                    }
                    break;
                }

                if (!string.IsNullOrEmpty(prop.Name))
                    result.Properties.Add(prop);
            }

            // 2) Extract blocks defined by AILab_Block_Start / AILab_Block_End
            int idx = 0;
            while (idx < lines.Length)
            {
                // Track section changes
                var secMatch = ReSectionTag.Match(lines[idx]);
                if (secMatch.Success)
                {
                    string secName = secMatch.Groups[1].Value.ToLowerInvariant();
                    if (secName.Contains("vertex")) currentSection = ShaderSectionType.Vertex;
                    else if (secName.Contains("fragment")) currentSection = ShaderSectionType.Fragment;
                    else if (secName.Contains("helper")) currentSection = ShaderSectionType.Helper;
                    else if (secName.Contains("constant")) currentSection = ShaderSectionType.Constants;
                    consumed[idx] = true;
                    idx++;
                    continue;
                }

                var bsm = ReBlockStartTag.Match(lines[idx]);
                if (!bsm.Success) { idx++; continue; }

                consumed[idx] = true;
                var parsedBlock = new ParsedBlock
                {
                    Title = bsm.Groups[1].Value,
                    Section = currentSection
                };

                var codeLines = new List<string>();
                idx++;

                while (idx < lines.Length)
                {
                    if (ReBlockEndTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        break;
                    }

                    var im = ReIntentTag.Match(lines[idx]);
                    if (im.Success)
                    {
                        parsedBlock.Intent = im.Groups[1].Value;
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    var prm = ReParamTag.Match(lines[idx]);
                    if (prm.Success)
                    {
                        parsedBlock.ReferencedParams.Add(prm.Groups[1].Value);
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    // Skip property lines inside blocks
                    if (RePropertyTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    if (!consumed[idx])
                        codeLines.Add(lines[idx]);
                    consumed[idx] = true;
                    idx++;
                }

                parsedBlock.Code = DedentParsedLines(codeLines);
                result.Blocks.Add(parsedBlock);
            }

            // 3) Leftover code (not inside any block tags and not property declarations)
            var leftover = new List<string>();
            for (int i = 0; i < lines.Length; i++)
            {
                if (!consumed[i]) leftover.Add(lines[i]);
            }
            result.LeftoverCode = DedentParsedLines(leftover);

            return result;
        }

        static string DedentParsedLines(List<string> lines)
        {
            if (lines.Count == 0) return "";

            int minIndent = int.MaxValue;
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) continue;
                int spaces = 0;
                foreach (char c in line)
                {
                    if (c == ' ') spaces++;
                    else if (c == '\t') spaces += 4;
                    else break;
                }
                if (spaces < minIndent) minIndent = spaces;
            }

            if (minIndent <= 0 || minIndent == int.MaxValue)
                return string.Join("\n", lines).Trim();

            var result = new List<string>();
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) { result.Add(""); continue; }
                int removed = 0, i = 0;
                while (removed < minIndent && i < line.Length)
                {
                    if (line[i] == ' ') { removed++; i++; }
                    else if (line[i] == '\t') { removed += 4; i++; }
                    else break;
                }
                result.Add(line.Substring(i));
            }
            return string.Join("\n", result).Trim();
        }

        static ShaderPropertyType ParsePropertyType(string raw)
        {
            switch (raw.ToLowerInvariant())
            {
                case "float":     return ShaderPropertyType.Float;
                case "range":     return ShaderPropertyType.Range;
                case "color":     return ShaderPropertyType.Color;
                case "vector":    return ShaderPropertyType.Vector;
                case "2d":
                case "texture2d": return ShaderPropertyType.Texture2D;
                case "3d":
                case "texture3d": return ShaderPropertyType.Texture3D;
                case "cube":
                case "cubemap":   return ShaderPropertyType.Cubemap;
                case "int":
                case "integer":   return ShaderPropertyType.Int;
                default:          return ShaderPropertyType.Float;
            }
        }

        // ---- Inline Insert Prompt ----

        public static string BuildInlineInsertPrompt(string blockCode, int cursorPosition, string userRequest)
        {
            var sb = new StringBuilder();
            sb.AppendLine("INLINE CODE INSERTION REQUEST");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(blockCode))
            {
                string before = cursorPosition > 0 && cursorPosition <= blockCode.Length
                    ? blockCode.Substring(0, cursorPosition) : blockCode;
                string after = cursorPosition >= 0 && cursorPosition < blockCode.Length
                    ? blockCode.Substring(cursorPosition) : "";

                sb.AppendLine("CODE BEFORE CURSOR:");
                sb.AppendLine("```hlsl");
                sb.AppendLine(before);
                sb.AppendLine("```");
                sb.AppendLine();

                if (!string.IsNullOrEmpty(after.Trim()))
                {
                    sb.AppendLine("CODE AFTER CURSOR:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(after);
                    sb.AppendLine("```");
                    sb.AppendLine();
                }
            }

            sb.AppendLine($"INSERT REQUEST: {userRequest}");
            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code snippet to insert at the cursor position. No surrounding function signatures or existing code. Just the new lines to insert. Wrap in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Data Flow Prompts ----

        const string DataFlowSystemPrompt = @"You are an expert in Unity URP shader development.
Your task is to determine which vertex input (Attributes/a2v) and fragment input (Varyings/v2f) fields are needed to implement a described visual effect.

Available Attributes fields: positionOS, normalOS, tangentOS, uv, uv2, color
Available Varyings fields: positionCS, normalWS, tangentWS, bitangentWS, uv, positionWS, viewDirWS, fogFactor, shadowCoord, vertexColor, screenPos

Global uniforms (always available, no struct needed): _Time, _SinTime, _CosTime, unity_DeltaTime, _WorldSpaceCameraPos, _ScreenParams
Textures/Samplers: declared automatically from shader Properties (need UV in Varyings to sample them)

Dependencies (Varyings field requires Attributes field):
- positionCS requires positionOS
- positionWS requires positionOS
- normalWS requires normalOS
- tangentWS requires tangentOS
- bitangentWS requires normalOS + tangentOS
- uv requires uv
- fogFactor requires positionOS
- shadowCoord requires positionOS
- viewDirWS requires positionOS
- vertexColor requires color
- screenPos requires positionOS

RULES:
1. positionCS is always required and always active - do not include it in your response.
2. positionOS is always required and always active - do not include it in your response.
3. Only list Varyings fields that need to be ACTIVATED for the requested effect.
4. If the effect needs texture sampling, include ""uv"" in activate_varyings.
5. Global uniforms like _Time are always available; do NOT include them in activate_varyings.
6. Respond in EXACTLY this JSON format, nothing else:

{
  ""activate_varyings"": [""fieldName1"", ""fieldName2""],
  ""annotations"": {
    ""fieldName1"": ""Brief reason this field is needed"",
    ""fieldName2"": ""Brief reason this field is needed""
  }
}

The annotations should explain WHY each field is needed in the context of the user's request.
Only activate Varyings fields; their Attributes dependencies will be auto-resolved.";

        public static string BuildDataFlowSystemPrompt(ShaderDocument doc)
        {
            var sb = new StringBuilder(DataFlowSystemPrompt);
            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine($"CURRENT STATE:");
                sb.AppendLine($"- Active Attributes: {FormatActiveFields(doc.DataFlow, DataFlowStage.Attributes)}");
                sb.AppendLine($"- Active Varyings: {FormatActiveFields(doc.DataFlow, DataFlowStage.Varyings)}");
            }
            return sb.ToString();
        }

        public static string BuildDataFlowUserPrompt(string userRequest)
        {
            return $"USER REQUEST: {userRequest}\n\nDetermine which Varyings fields to activate and provide annotations. Respond ONLY with the JSON.";
        }

        static readonly Regex ReJsonBlock = new Regex(
            @"\{[\s\S]*?""activate_varyings""[\s\S]*?\}",
            RegexOptions.Compiled);

        static readonly Regex ReFieldArray = new Regex(
            @"""activate_varyings""\s*:\s*\[(.*?)\]",
            RegexOptions.Compiled | RegexOptions.Singleline);

        static readonly Regex ReAnnotation = new Regex(
            @"""(\w+)""\s*:\s*""([^""]+)""",
            RegexOptions.Compiled);

        /// <summary>
        /// Parse the LLM's JSON response for Data Flow field activation.
        /// Returns (list of varying field names to activate, dict of annotations).
        /// </summary>
        public static (List<string> fields, Dictionary<string, string> annotations) ParseDataFlowResponse(string response)
        {
            var fields = new List<string>();
            var annotations = new Dictionary<string, string>();

            if (string.IsNullOrEmpty(response))
                return (fields, annotations);

            string json = response;
            var codeMatch = ReCodeBlock.Match(response);
            if (codeMatch.Success)
                json = codeMatch.Groups[1].Value;

            var jsonMatch = ReJsonBlock.Match(json);
            if (jsonMatch.Success)
                json = jsonMatch.Value;

            var arrMatch = ReFieldArray.Match(json);
            if (arrMatch.Success)
            {
                var items = Regex.Matches(arrMatch.Groups[1].Value, @"""(\w+)""");
                foreach (Match m in items)
                    fields.Add(m.Groups[1].Value);
            }

            var annotSection = Regex.Match(json, @"""annotations""\s*:\s*\{([\s\S]*?)\}", RegexOptions.Singleline);
            if (annotSection.Success)
            {
                foreach (Match am in ReAnnotation.Matches(annotSection.Groups[1].Value))
                    annotations[am.Groups[1].Value] = am.Groups[2].Value;
            }

            return (fields, annotations);
        }

        // ---- Helpers ----

        static string FormatProperties(ShaderDocument doc)
        {
            if (doc.Properties.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var p in doc.Properties)
                sb.Append($"{p.Name}({p.PropertyType}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatBlocks(ShaderDocument doc)
        {
            if (doc.Blocks.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var b in doc.Blocks)
                sb.Append($"\"{b.Title}\"({b.Section}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatActiveFields(DataFlowGraph graph, DataFlowStage stage)
        {
            if (graph == null) return "(none)";
            var active = graph.GetActiveFields(stage);
            if (active.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var f in active)
                sb.Append($"{f.Name}, ");
            return sb.ToString().TrimEnd(',', ' ');
        }
    }
}
