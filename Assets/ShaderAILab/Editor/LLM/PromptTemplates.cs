using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using ShaderAILab.Editor.Core;

namespace ShaderAILab.Editor.LLM
{
    /// <summary>
    /// Constructs system and user prompts tailored for shader generation.
    /// Handles both global (auto-place) and targeted (specific block/section) modes.
    /// </summary>
    public static class PromptTemplates
    {
        const string CoreSystemPrompt = @"You are an expert HLSL shader programmer for Unity's Universal Render Pipeline (URP).

RULES:
1. Output ONLY valid HLSL code. No markdown, no explanations outside code comments.
2. Use URP conventions: CBUFFER_START/END, TEXTURE2D/SAMPLER macros, Packages/com.unity.render-pipelines.universal/ShaderLibrary includes.
3. Write self-contained functions. Each function should have clear inputs and outputs.
4. Always expose tunable parameters as shader properties. For any magic number that affects visual appearance, create a property with a sensible Range.
5. Use float/half types appropriately (half for colors and normalized values, float for positions).
6. Include AILab metadata tags in your output:
   - Wrap each logical function with: // [AILab_Block_Start: ""<Title>""] and // [AILab_Block_End]
   - The <Title> MUST be a SHORT English name (2-5 words, like ""PBR Lighting"", ""Toon Shading"", ""Rim Light Effect""). Do NOT use the user's prompt as the title.
   - Add intent: // [AILab_Intent: ""<description>""]
   - Reference parameters: // [AILab_Param: ""_ParamName"" role=""<role>""]
   - Declare properties: // [AILab_Property: name=""_Name"" display=""Display Name"" type=""Range"" min=""0"" max=""1"" default=""0.5""]
7. If generating a property, include BOTH the AILab_Property tag AND the Unity property declaration line.
   Place ALL property tags BEFORE the block code, NOT inside the function body.
8. Code must compile without errors in URP.
9. IMPORTANT: Your function must ONLY reference properties that already exist in the shader OR that you declare with AILab_Property tags.
   Do NOT reference undeclared variables. Every variable used in the function body must either be:
   (a) declared as a function parameter, (b) a local variable, (c) a property you declared with AILab_Property,
   (d) a field from the Varyings/Attributes struct, or (e) a URP built-in.
10. Fragment functions should have signature: half4 FuncName(Varyings input) { ... }
    Vertex functions should have signature: void FuncName(inout float3 posOS) { ... }
    Helper functions can have any signature.
11. NEVER generate CBUFFER_START/CBUFFER_END blocks, struct Attributes, struct Varyings, or variable declaration blocks.
    These are auto-generated by the system from the properties you declare with AILab_Property tags.
    Your code should ONLY contain function definitions wrapped in AILab_Block_Start/End tags, plus AILab_Property tags for any new properties.
12. Do NOT create blocks whose sole purpose is declaring variables or properties. Only create function blocks.

MULTI-PASS SUPPORT:
When the user requests a NEW PASS (e.g. outline pass, shadow pass, custom effect pass), you MUST:
1. Use the // [AILab_Pass: name=""PassName"" lightmode=""LightModeTag""] tag BEFORE the block code.
   - name: A short English name (e.g. ""Outline"", ""Silhouette"", ""CustomShadow"").
   - lightmode: The URP LightMode tag (e.g. ""SRPDefaultUnlit"" for outline/unlit extra passes, ""UniversalForward"" for lit passes).
2. After the pass tag, optionally specify per-pass render state overrides:
   // [AILab_PassState: cull=""Front"" zwrite=""On""]
   Common overrides: cull (Back/Front/Off), blend (e.g. ""SrcAlpha OneMinusSrcAlpha""), zwrite (On/Off).
3. Then provide the vertex and fragment blocks for this NEW pass, wrapped in AILab_Block_Start/End tags as usual.
4. Each pass has its OWN vertex and fragment functions. A typical outline pass needs:
   - A vertex block that extrudes vertices along normals
   - A fragment block that returns a solid outline color
5. Include // [AILab_Section: ""Vertex""] and // [AILab_Section: ""Fragment""] tags to mark which section each block belongs to.
6. The system will automatically create the new pass with its own Attributes/Varyings structs, includes, and pragmas.

Example for an outline pass:
```
// [AILab_Property: name=""_OutlineWidth"" display=""Outline Width"" type=""Range"" min=""0"" max=""0.1"" default=""0.02""]
_OutlineWidth(""Outline Width"", Range(0,0.1)) = 0.02
// [AILab_Property: name=""_OutlineColor"" display=""Outline Color"" type=""Color"" default=""(0,0,0,1)""]
_OutlineColor(""Outline Color"", Color) = (0,0,0,1)

// [AILab_Pass: name=""Outline"" lightmode=""SRPDefaultUnlit""]
// [AILab_PassState: cull=""Front""]
// [AILab_Section: ""Vertex""]
// [AILab_Block_Start: ""Outline Extrusion""]
// [AILab_Intent: ""Extrude vertices along normals for outline effect""]
// [AILab_Param: ""_OutlineWidth"" role=""extrusion_distance""]
void ExtrudeOutline(inout float3 posOS) {
    float3 normalOS = normalize(posOS);
    posOS += normalOS * _OutlineWidth;
}
// [AILab_Block_End]
// [AILab_Section: ""Fragment""]
// [AILab_Block_Start: ""Outline Color""]
// [AILab_Intent: ""Return solid outline color""]
// [AILab_Param: ""_OutlineColor"" role=""outline_color""]
half4 OutlineColor(Varyings input) {
    return _OutlineColor;
}
// [AILab_Block_End]
```

TEXTURE & SAMPLER CONVENTIONS:
- The system auto-generates TEXTURE2D/TEXTURE3D/TEXTURECUBE declarations and matching SAMPLER declarations from your AILab_Property tags.
- The system also auto-generates float4 {Name}_ST in the CBUFFER for tiling/offset.
- To declare a Texture2D property, use: // [AILab_Property: name=""_MyTex"" display=""My Texture"" type=""Texture2D"" defaultTex=""white""]
  followed by: _MyTex(""My Texture"", 2D) = ""white"" {}
  Valid defaultTex values: ""white"", ""black"", ""gray"", ""bump"", ""red""
- To declare a Cubemap property: type=""Cubemap"", declaration uses Cube.
- To declare a Texture3D property: type=""Texture3D"", declaration uses 3D.
- In your function code, sample textures using URP macros:
    half4 col = SAMPLE_TEXTURE2D(_MyTex, sampler_MyTex, uv);
    half4 cubeCol = SAMPLE_TEXTURECUBE(_MyCube, sampler_MyCube, reflectDir);
    half4 tex3d = SAMPLE_TEXTURE3D(_MyTex3D, sampler_MyTex3D, uvw);
- For tiling/offset, apply: float2 uv = input.uv * _MyTex_ST.xy + _MyTex_ST.zw;
  Or use the macro: float2 uv = TRANSFORM_TEX(input.uv, _MyTex);
- The sampler name is always sampler{PropertyName}, e.g. sampler_MainTex for _MainTex.";

        // ---- System Prompt ----

        public static string BuildSystemPrompt(ShaderDocument doc, string targetContext)
        {
            var sb = new StringBuilder(CoreSystemPrompt);

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Render settings: Cull={doc.GlobalSettings.CullMode}, Blend={doc.GlobalSettings.BlendMode}, ZWrite={doc.GlobalSettings.ZWriteMode}");
                sb.AppendLine($"- Passes: {FormatPasses(doc)}");

                var activePass = doc.ActivePass;
                if (activePass != null)
                {
                    sb.AppendLine($"- Active pass: \"{activePass.Name}\" (LightMode={activePass.LightMode})");
                    sb.AppendLine($"- Blocks in active pass: {FormatPassBlocks(activePass)}");
                    if (activePass.DataFlow != null)
                    {
                        sb.AppendLine($"- Active Attributes fields: {FormatActiveFields(activePass.DataFlow, DataFlowStage.Attributes)}");
                        sb.AppendLine($"- Active Varyings fields: {FormatActiveFields(activePass.DataFlow, DataFlowStage.Varyings)}");
                    }
                }
            }

            if (!string.IsNullOrEmpty(targetContext))
            {
                sb.AppendLine();
                if (targetContext == "New Pass")
                {
                    sb.AppendLine("TARGET: Generate a COMPLETE NEW SHADER PASS. You MUST include the // [AILab_Pass: ...] tag, and provide BOTH a vertex block and a fragment block for this new pass. Follow the MULTI-PASS SUPPORT instructions above.");
                }
                else if (targetContext.StartsWith("Block:"))
                {
                    sb.AppendLine($"TARGET: You are editing an existing block. Replace its code completely. Keep the same function signature if possible.");
                }
                else if (targetContext.Contains("Vertex"))
                {
                    sb.AppendLine("TARGET: Generate a VERTEX shader function. It should modify vertex positions (inout float3 positionOS) or other vertex attributes.");
                }
                else if (targetContext.Contains("Fragment"))
                {
                    sb.AppendLine("TARGET: Generate a FRAGMENT shader function. It should compute and return a color (half4).");
                }
                else if (targetContext.Contains("Helper"))
                {
                    sb.AppendLine("TARGET: Generate a helper/utility function that can be called from vertex or fragment functions.");
                }
                else
                {
                    sb.AppendLine("TARGET: Auto-determine the best location (vertex, fragment, or helper) for the requested functionality. If the user is asking for a new render pass (e.g. outline, silhouette, second pass), generate a COMPLETE NEW SHADER PASS with the // [AILab_Pass: ...] tag.");
                }
            }

            return sb.ToString();
        }

        // ---- User Prompt ----

        public static string BuildUserPrompt(string userRequest, ShaderDocument doc, string targetContext)
        {
            var sb = new StringBuilder();

            if (targetContext != null && targetContext.StartsWith("Block:"))
            {
                string blockTitle = targetContext.Substring(7).Trim();
                var block = doc?.FindBlockByTitle(blockTitle);
                if (block != null)
                {
                    sb.AppendLine("EXISTING CODE IN THIS BLOCK:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(block.Code);
                    sb.AppendLine("```");
                    sb.AppendLine();
                    sb.AppendLine("MODIFICATION REQUEST:");
                }
            }

            sb.AppendLine(userRequest);

            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code with AILab tags. If you need new properties, include their declarations. Wrap your code in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Response Parsing ----

        static readonly Regex ReCodeBlock = new Regex(
            @"```(?:hlsl|glsl|shader|c)?\s*\n([\s\S]*?)```",
            RegexOptions.Compiled);

        static readonly Regex RePropertyTag = new Regex(
            @"//\s*\[AILab_Property:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReBlockStartTag = new Regex(
            @"//\s*\[AILab_Block_Start:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReBlockEndTag = new Regex(
            @"//\s*\[AILab_Block_End\]", RegexOptions.Compiled);

        static readonly Regex ReIntentTag = new Regex(
            @"//\s*\[AILab_Intent:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReParamTag = new Regex(
            @"//\s*\[AILab_Param:\s*""([^""]+)""\s+role=""([^""]*)""\]", RegexOptions.Compiled);

        static readonly Regex ReSectionTag = new Regex(
            @"//\s*\[AILab_Section:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex RePassTag = new Regex(
            @"//\s*\[AILab_Pass:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex RePassStateTag = new Regex(
            @"//\s*\[AILab_PassState:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReKV = new Regex(
            @"(\w+)=""([^""]*?)""", RegexOptions.Compiled);

        /// <summary>
        /// Extract clean HLSL code from an LLM response that may contain markdown formatting.
        /// </summary>
        public static string ExtractCodeFromResponse(string response)
        {
            if (string.IsNullOrEmpty(response)) return response;

            var match = ReCodeBlock.Match(response);
            if (match.Success)
                return match.Groups[1].Value.Trim();

            string trimmed = response.Trim();
            if (trimmed.StartsWith("//") || trimmed.StartsWith("void") ||
                trimmed.StartsWith("half") || trimmed.StartsWith("float") ||
                trimmed.StartsWith("struct") || trimmed.StartsWith("CBUFFER") ||
                trimmed.StartsWith("// [AILab"))
            {
                return trimmed;
            }

            return trimmed;
        }

        /// <summary>
        /// Result of parsing a full LLM response: extracted properties, blocks, and
        /// any leftover code that wasn't inside a block tag.
        /// </summary>
        public class ParsedLLMResponse
        {
            public List<ShaderProperty> Properties = new List<ShaderProperty>();
            public List<ParsedBlock> Blocks = new List<ParsedBlock>();
            public string LeftoverCode = "";
            public ParsedPassInfo PassInfo;
        }

        public class ParsedBlock
        {
            public string Title;
            public string Intent;
            public string Code;
            public ShaderSectionType Section;
            public List<string> ReferencedParams = new List<string>();
        }

        public class ParsedPassInfo
        {
            public string Name;
            public string LightMode;
            public string CullOverride;
            public string BlendOverride;
            public string ZWriteOverride;
        }

        /// <summary>
        /// Parse the full LLM response to extract all properties, blocks with
        /// proper titles, and section information.
        /// </summary>
        public static ParsedLLMResponse ParseFullResponse(string response, ShaderSectionType defaultSection)
        {
            var result = new ParsedLLMResponse();
            string code = ExtractCodeFromResponse(response);
            if (string.IsNullOrEmpty(code)) return result;

            string[] lines = code.Split(new[] { "\r\n", "\n" }, System.StringSplitOptions.None);

            // Track which lines belong to blocks vs leftover
            bool[] consumed = new bool[lines.Length];
            ShaderSectionType currentSection = defaultSection;

            // 1) Extract properties (and their Unity declaration on the next line)
            for (int i = 0; i < lines.Length; i++)
            {
                var pm = RePropertyTag.Match(lines[i]);
                if (!pm.Success) continue;

                var prop = new ShaderProperty();
                foreach (Match kv in ReKV.Matches(pm.Groups[1].Value))
                {
                    string key = kv.Groups[1].Value.ToLowerInvariant();
                    string val = kv.Groups[2].Value;
                    switch (key)
                    {
                        case "name":       prop.Name           = val; break;
                        case "display":    prop.DisplayName    = val; break;
                        case "type":       prop.PropertyType   = ParsePropertyType(val); break;
                        case "default":    prop.DefaultValue   = val; break;
                        case "min":        if (float.TryParse(val, out float mn)) prop.MinValue = mn; break;
                        case "max":        if (float.TryParse(val, out float mx)) prop.MaxValue = mx; break;
                        case "role":       prop.Role           = val; break;
                        case "defaulttex": prop.DefaultTexture = val; break;
                    }
                }

                consumed[i] = true;

                // Check next non-empty line for raw Unity declaration
                for (int j = i + 1; j < lines.Length && j <= i + 3; j++)
                {
                    string trimmed = lines[j].Trim();
                    if (string.IsNullOrEmpty(trimmed)) continue;
                    if (trimmed.StartsWith("//")) continue;
                    // Looks like a Unity property declaration (e.g. _Foo("Bar", Float) = 0)
                    if (trimmed.StartsWith("_") && trimmed.Contains("("))
                    {
                        prop.RawDeclaration = trimmed;
                        consumed[j] = true;
                    }
                    break;
                }

                if (!string.IsNullOrEmpty(prop.Name))
                    result.Properties.Add(prop);
            }

            // 1.5) Detect AILab_Pass and AILab_PassState tags
            for (int i = 0; i < lines.Length; i++)
            {
                var passMatch = RePassTag.Match(lines[i]);
                if (passMatch.Success)
                {
                    result.PassInfo = new ParsedPassInfo();
                    foreach (Match kv in ReKV.Matches(passMatch.Groups[1].Value))
                    {
                        string key = kv.Groups[1].Value.ToLowerInvariant();
                        string val = kv.Groups[2].Value;
                        switch (key)
                        {
                            case "name": result.PassInfo.Name = val; break;
                            case "lightmode": result.PassInfo.LightMode = val; break;
                        }
                    }
                    consumed[i] = true;
                }

                var stateMatch = RePassStateTag.Match(lines[i]);
                if (stateMatch.Success)
                {
                    if (result.PassInfo == null) result.PassInfo = new ParsedPassInfo();
                    foreach (Match kv in ReKV.Matches(stateMatch.Groups[1].Value))
                    {
                        string key = kv.Groups[1].Value.ToLowerInvariant();
                        string val = kv.Groups[2].Value;
                        switch (key)
                        {
                            case "cull": result.PassInfo.CullOverride = val; break;
                            case "blend": result.PassInfo.BlendOverride = val; break;
                            case "zwrite": result.PassInfo.ZWriteOverride = val; break;
                        }
                    }
                    consumed[i] = true;
                }
            }

            // 2) Extract blocks defined by AILab_Block_Start / AILab_Block_End
            int idx = 0;
            while (idx < lines.Length)
            {
                // Track section changes
                var secMatch = ReSectionTag.Match(lines[idx]);
                if (secMatch.Success)
                {
                    string secName = secMatch.Groups[1].Value.ToLowerInvariant();
                    if (secName.Contains("vertex")) currentSection = ShaderSectionType.Vertex;
                    else if (secName.Contains("fragment")) currentSection = ShaderSectionType.Fragment;
                    else if (secName.Contains("helper")) currentSection = ShaderSectionType.Helper;
                    else if (secName.Contains("constant")) currentSection = ShaderSectionType.Constants;
                    consumed[idx] = true;
                    idx++;
                    continue;
                }

                var bsm = ReBlockStartTag.Match(lines[idx]);
                if (!bsm.Success) { idx++; continue; }

                consumed[idx] = true;
                var parsedBlock = new ParsedBlock
                {
                    Title = bsm.Groups[1].Value,
                    Section = currentSection
                };

                var codeLines = new List<string>();
                idx++;

                while (idx < lines.Length)
                {
                    if (ReBlockEndTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        break;
                    }

                    var im = ReIntentTag.Match(lines[idx]);
                    if (im.Success)
                    {
                        parsedBlock.Intent = im.Groups[1].Value;
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    var prm = ReParamTag.Match(lines[idx]);
                    if (prm.Success)
                    {
                        parsedBlock.ReferencedParams.Add(prm.Groups[1].Value);
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    // Skip property lines inside blocks
                    if (RePropertyTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    if (!consumed[idx])
                        codeLines.Add(lines[idx]);
                    consumed[idx] = true;
                    idx++;
                }

                parsedBlock.Code = DedentParsedLines(codeLines);
                result.Blocks.Add(parsedBlock);
            }

            // 3) Leftover code (not inside any block tags and not property declarations)
            var leftover = new List<string>();
            for (int i = 0; i < lines.Length; i++)
            {
                if (!consumed[i]) leftover.Add(lines[i]);
            }
            result.LeftoverCode = DedentParsedLines(leftover);

            return result;
        }

        static string DedentParsedLines(List<string> lines)
        {
            if (lines.Count == 0) return "";

            int minIndent = int.MaxValue;
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) continue;
                int spaces = 0;
                foreach (char c in line)
                {
                    if (c == ' ') spaces++;
                    else if (c == '\t') spaces += 4;
                    else break;
                }
                if (spaces < minIndent) minIndent = spaces;
            }

            if (minIndent <= 0 || minIndent == int.MaxValue)
                return string.Join("\n", lines).Trim();

            var result = new List<string>();
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) { result.Add(""); continue; }
                int removed = 0, i = 0;
                while (removed < minIndent && i < line.Length)
                {
                    if (line[i] == ' ') { removed++; i++; }
                    else if (line[i] == '\t') { removed += 4; i++; }
                    else break;
                }
                result.Add(line.Substring(i));
            }
            return string.Join("\n", result).Trim();
        }

        static ShaderPropertyType ParsePropertyType(string raw)
        {
            switch (raw.ToLowerInvariant())
            {
                case "float":     return ShaderPropertyType.Float;
                case "range":     return ShaderPropertyType.Range;
                case "color":     return ShaderPropertyType.Color;
                case "vector":    return ShaderPropertyType.Vector;
                case "2d":
                case "texture2d": return ShaderPropertyType.Texture2D;
                case "3d":
                case "texture3d": return ShaderPropertyType.Texture3D;
                case "cube":
                case "cubemap":   return ShaderPropertyType.Cubemap;
                case "int":
                case "integer":   return ShaderPropertyType.Int;
                default:          return ShaderPropertyType.Float;
            }
        }

        // ---- Inline Insert Prompt ----

        public static string BuildInlineInsertPrompt(string blockCode, int cursorPosition, string userRequest)
        {
            var sb = new StringBuilder();
            sb.AppendLine("INLINE CODE INSERTION REQUEST");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(blockCode))
            {
                string before = cursorPosition > 0 && cursorPosition <= blockCode.Length
                    ? blockCode.Substring(0, cursorPosition) : blockCode;
                string after = cursorPosition >= 0 && cursorPosition < blockCode.Length
                    ? blockCode.Substring(cursorPosition) : "";

                sb.AppendLine("CODE BEFORE CURSOR:");
                sb.AppendLine("```hlsl");
                sb.AppendLine(before);
                sb.AppendLine("```");
                sb.AppendLine();

                if (!string.IsNullOrEmpty(after.Trim()))
                {
                    sb.AppendLine("CODE AFTER CURSOR:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(after);
                    sb.AppendLine("```");
                    sb.AppendLine();
                }
            }

            sb.AppendLine($"INSERT REQUEST: {userRequest}");
            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code snippet to insert at the cursor position. No surrounding function signatures or existing code. Just the new lines to insert. Wrap in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Data Flow Prompts ----

        const string DataFlowSystemPrompt = @"You are an expert in Unity URP shader development.
Your task is to determine which vertex input (Attributes/a2v) and fragment input (Varyings/v2f) fields are needed to implement a described visual effect.

Available Attributes fields: positionOS, normalOS, tangentOS, uv, uv2, color
Available Varyings fields: positionCS, normalWS, tangentWS, bitangentWS, uv, positionWS, viewDirWS, fogFactor, shadowCoord, vertexColor, screenPos

Global uniforms (always available, no struct needed): _Time, _SinTime, _CosTime, unity_DeltaTime, _WorldSpaceCameraPos, _ScreenParams
Textures/Samplers: declared automatically from shader Properties (need UV in Varyings to sample them)

Dependencies (Varyings field requires Attributes field):
- positionCS requires positionOS
- positionWS requires positionOS
- normalWS requires normalOS
- tangentWS requires tangentOS
- bitangentWS requires normalOS + tangentOS
- uv requires uv
- fogFactor requires positionOS
- shadowCoord requires positionOS
- viewDirWS requires positionOS
- vertexColor requires color
- screenPos requires positionOS

RULES:
1. positionCS is always required and always active - do not include it in your response.
2. positionOS is always required and always active - do not include it in your response.
3. Only list Varyings fields that need to be ACTIVATED for the requested effect.
4. If the effect needs texture sampling, include ""uv"" in activate_varyings.
5. Global uniforms like _Time are always available; do NOT include them in activate_varyings.
6. Respond in EXACTLY this JSON format, nothing else:

{
  ""activate_varyings"": [""fieldName1"", ""fieldName2""],
  ""annotations"": {
    ""fieldName1"": ""Brief reason this field is needed"",
    ""fieldName2"": ""Brief reason this field is needed""
  }
}

The annotations should explain WHY each field is needed in the context of the user's request.
Only activate Varyings fields; their Attributes dependencies will be auto-resolved.";

        public static string BuildDataFlowSystemPrompt(ShaderDocument doc)
        {
            var sb = new StringBuilder(DataFlowSystemPrompt);
            if (doc != null)
            {
                var dataFlow = doc.ActivePass?.DataFlow;
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine($"CURRENT STATE:");
                if (doc.ActivePass != null)
                    sb.AppendLine($"- Active pass: \"{doc.ActivePass.Name}\" (LightMode={doc.ActivePass.LightMode})");
                if (dataFlow != null)
                {
                    sb.AppendLine($"- Active Attributes: {FormatActiveFields(dataFlow, DataFlowStage.Attributes)}");
                    sb.AppendLine($"- Active Varyings: {FormatActiveFields(dataFlow, DataFlowStage.Varyings)}");
                }
            }
            return sb.ToString();
        }

        public static string BuildDataFlowUserPrompt(string userRequest)
        {
            return $"USER REQUEST: {userRequest}\n\nDetermine which Varyings fields to activate and provide annotations. Respond ONLY with the JSON.";
        }

        static readonly Regex ReJsonBlock = new Regex(
            @"\{[\s\S]*?""activate_varyings""[\s\S]*?\}",
            RegexOptions.Compiled);

        static readonly Regex ReFieldArray = new Regex(
            @"""activate_varyings""\s*:\s*\[(.*?)\]",
            RegexOptions.Compiled | RegexOptions.Singleline);

        static readonly Regex ReAnnotation = new Regex(
            @"""(\w+)""\s*:\s*""([^""]+)""",
            RegexOptions.Compiled);

        /// <summary>
        /// Parse the LLM's JSON response for Data Flow field activation.
        /// Returns (list of varying field names to activate, dict of annotations).
        /// </summary>
        public static (List<string> fields, Dictionary<string, string> annotations) ParseDataFlowResponse(string response)
        {
            var fields = new List<string>();
            var annotations = new Dictionary<string, string>();

            if (string.IsNullOrEmpty(response))
                return (fields, annotations);

            string json = response;
            var codeMatch = ReCodeBlock.Match(response);
            if (codeMatch.Success)
                json = codeMatch.Groups[1].Value;

            var jsonMatch = ReJsonBlock.Match(json);
            if (jsonMatch.Success)
                json = jsonMatch.Value;

            var arrMatch = ReFieldArray.Match(json);
            if (arrMatch.Success)
            {
                var items = Regex.Matches(arrMatch.Groups[1].Value, @"""(\w+)""");
                foreach (Match m in items)
                    fields.Add(m.Groups[1].Value);
            }

            var annotSection = Regex.Match(json, @"""annotations""\s*:\s*\{([\s\S]*?)\}", RegexOptions.Singleline);
            if (annotSection.Success)
            {
                foreach (Match am in ReAnnotation.Matches(annotSection.Groups[1].Value))
                    annotations[am.Groups[1].Value] = am.Groups[2].Value;
            }

            return (fields, annotations);
        }

        // ---- Helpers ----

        static string FormatProperties(ShaderDocument doc)
        {
            if (doc.Properties.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var p in doc.Properties)
                sb.Append($"{p.Name}({p.PropertyType}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatPasses(ShaderDocument doc)
        {
            if (doc.Passes.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var p in doc.Passes)
            {
                if (p.IsUsePass)
                    sb.Append($"[UsePass:\"{p.UsePassPath}\"], ");
                else
                    sb.Append($"\"{p.Name}\"(LightMode={p.LightMode}), ");
            }
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatPassBlocks(ShaderPass pass)
        {
            if (pass == null || pass.Blocks.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var b in pass.Blocks)
                sb.Append($"\"{b.Title}\"({b.Section}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatActiveFields(DataFlowGraph graph, DataFlowStage stage)
        {
            if (graph == null) return "(none)";
            var active = graph.GetActiveFields(stage);
            if (active.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var f in active)
                sb.Append($"{f.Name}, ");
            return sb.ToString().TrimEnd(',', ' ');
        }
    }
}
