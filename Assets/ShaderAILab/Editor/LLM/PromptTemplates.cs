using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using ShaderAILab.Editor.Core;
using PropertyMeta = ShaderAILab.Editor.ShaderAILabGUI.PropertyMeta;

namespace ShaderAILab.Editor.LLM
{
    /// <summary>
    /// Constructs system and user prompts tailored for shader generation.
    /// Handles both global (auto-place) and targeted (specific block/section) modes.
    /// </summary>
    public static class PromptTemplates
    {
        const string CoreSystemPrompt = @"You are an expert HLSL shader programmer for Unity's Universal Render Pipeline (URP).

RULES:
1. Output ONLY valid HLSL code. No markdown, no explanations outside code comments.
2. Use URP conventions: CBUFFER_START/END, TEXTURE2D/SAMPLER macros, Packages/com.unity.render-pipelines.universal/ShaderLibrary includes.
3. Write self-contained functions. Each function should have clear inputs and outputs.
4. Always expose tunable parameters as shader properties. For any magic number that affects visual appearance, create a property with a sensible Range.
5. Use float/half types appropriately (half for colors and normalized values, float for positions).
6. Include AILab metadata tags in your output:
   - Wrap each logical function with: // [AILab_Block_Start: ""<Title>""] and // [AILab_Block_End]
   - The <Title> MUST be a SHORT English name (2-5 words, like ""PBR Lighting"", ""Toon Shading"", ""Rim Light Effect""). Do NOT use the user's prompt as the title.
   - Add intent: // [AILab_Intent: ""<description>""]
   - Reference parameters: // [AILab_Param: ""_ParamName"" role=""<role>""]
   - Declare properties: // [AILab_Property: name=""_Name"" display=""Display Name"" type=""Range"" min=""0"" max=""1"" default=""0.5""]
7. If generating a property, include BOTH the AILab_Property tag AND the Unity property declaration line.
   Place ALL property tags BEFORE the block code, NOT inside the function body.
8. Code must compile without errors in URP.
9. IMPORTANT: Your function must ONLY reference properties that already exist in the shader OR that you declare with AILab_Property tags.
   Do NOT reference undeclared variables. Every variable used in the function body must either be:
   (a) declared as a function parameter, (b) a local variable, (c) a property you declared with AILab_Property,
   (d) a field from the Varyings/Attributes struct, or (e) a URP built-in.
10. Fragment functions should have signature: half4 FuncName(Varyings input) { ... }
    Vertex functions should have signature: void FuncName(inout float3 posOS) { ... }
    Helper functions can have any signature.
11. NEVER generate CBUFFER_START/CBUFFER_END blocks, struct Attributes, struct Varyings, or variable declaration blocks.
    These are auto-generated by the system from the properties you declare with AILab_Property tags.
    Your code should ONLY contain function definitions wrapped in AILab_Block_Start/End tags, plus AILab_Property tags for any new properties.
12. Do NOT create blocks whose sole purpose is declaring variables or properties. Only create function blocks.

MULTI-PASS SUPPORT:
When the user requests a NEW PASS (e.g. outline pass, shadow pass, custom effect pass), you MUST:
1. Use the // [AILab_Pass: name=""PassName"" lightmode=""LightModeTag""] tag BEFORE the block code.
   - name: A short English name (e.g. ""Outline"", ""Silhouette"", ""CustomShadow"").
   - lightmode: The URP LightMode tag (e.g. ""SRPDefaultUnlit"" for outline/unlit extra passes, ""UniversalForward"" for lit passes).
2. After the pass tag, optionally specify per-pass render state overrides:
   // [AILab_PassState: cull=""Front"" zwrite=""On"" ztest=""LEqual"" colormask=""RGB""]
   // [AILab_Stencil: ref=""1"" comp=""Always"" pass=""Replace"" fail=""Keep"" zfail=""Keep"" readmask=""255"" writemask=""255""]
   Supported overrides:
     - cull: Back, Front, Off
     - blend: e.g. ""SrcAlpha OneMinusSrcAlpha"", ""One One""
     - zwrite: On, Off
     - ztest: LEqual, Less, Equal, GEqual, Greater, NotEqual, Always
     - colormask: RGBA, RGB, R, G, B, A, 0
   Stencil tag fields (all optional, only include if needed):
     - ref: 0-255, comp: Always/Less/LEqual/Equal/GEqual/Greater/NotEqual/Never
     - pass/fail/zfail: Keep/Zero/Replace/IncrSat/DecrSat/Invert/IncrWrap/DecrWrap
     - readmask/writemask: 0-255
3. Then provide the vertex and fragment blocks for this NEW pass, wrapped in AILab_Block_Start/End tags as usual.
4. Each pass has its OWN vertex and fragment functions. A typical outline pass needs:
   - A vertex block that extrudes vertices along normals
   - A fragment block that returns a solid outline color
5. Include // [AILab_Section: ""Vertex""] and // [AILab_Section: ""Fragment""] tags to mark which section each block belongs to.
6. The system will automatically create the new pass with its own Attributes/Varyings structs, includes, and pragmas.

Example for an outline pass:
```
// [AILab_Property: name=""_OutlineWidth"" display=""Outline Width"" type=""Range"" min=""0"" max=""0.1"" default=""0.02""]
_OutlineWidth(""Outline Width"", Range(0,0.1)) = 0.02
// [AILab_Property: name=""_OutlineColor"" display=""Outline Color"" type=""Color"" default=""(0,0,0,1)""]
_OutlineColor(""Outline Color"", Color) = (0,0,0,1)

// [AILab_Pass: name=""Outline"" lightmode=""SRPDefaultUnlit""]
// [AILab_PassState: cull=""Front""]
// [AILab_Section: ""Vertex""]
// [AILab_Block_Start: ""Outline Extrusion""]
// [AILab_Intent: ""Extrude vertices along normals for outline effect""]
// [AILab_Param: ""_OutlineWidth"" role=""extrusion_distance""]
void ExtrudeOutline(inout float3 posOS) {
    float3 normalOS = normalize(posOS);
    posOS += normalOS * _OutlineWidth;
}
// [AILab_Block_End]
// [AILab_Section: ""Fragment""]
// [AILab_Block_Start: ""Outline Color""]
// [AILab_Intent: ""Return solid outline color""]
// [AILab_Param: ""_OutlineColor"" role=""outline_color""]
half4 OutlineColor(Varyings input) {
    return _OutlineColor;
}
// [AILab_Block_End]
```

TEXTURE & SAMPLER CONVENTIONS:
- The system auto-generates TEXTURE2D/TEXTURE3D/TEXTURECUBE declarations and matching SAMPLER declarations from your AILab_Property tags.
- The system also auto-generates float4 {Name}_ST in the CBUFFER for tiling/offset.
- To declare a Texture2D property, use: // [AILab_Property: name=""_MyTex"" display=""My Texture"" type=""Texture2D"" defaultTex=""white""]
  followed by: _MyTex(""My Texture"", 2D) = ""white"" {}
  Valid defaultTex values: ""white"", ""black"", ""gray"", ""bump"", ""red""
- To declare a Cubemap property: type=""Cubemap"", declaration uses Cube.
- To declare a Texture3D property: type=""Texture3D"", declaration uses 3D.
- In your function code, sample textures using URP macros:
    half4 col = SAMPLE_TEXTURE2D(_MyTex, sampler_MyTex, uv);
    half4 cubeCol = SAMPLE_TEXTURECUBE(_MyCube, sampler_MyCube, reflectDir);
    half4 tex3d = SAMPLE_TEXTURE3D(_MyTex3D, sampler_MyTex3D, uvw);
- For tiling/offset, apply: float2 uv = input.uv * _MyTex_ST.xy + _MyTex_ST.zw;
  Or use the macro: float2 uv = TRANSFORM_TEX(input.uv, _MyTex);
- The sampler name is always sampler{PropertyName}, e.g. sampler_MainTex for _MainTex.";

        // ---- System Prompt ----

        public static string BuildSystemPrompt(ShaderDocument doc, string targetContext,
            System.Collections.Generic.List<Core.ShaderCompileChecker.CompileError> compileErrors = null)
        {
            var sb = new StringBuilder(CoreSystemPrompt);

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Render settings: Cull={doc.GlobalSettings.CullMode}, Blend={doc.GlobalSettings.BlendMode}, ZWrite={doc.GlobalSettings.ZWriteMode}");
                sb.AppendLine($"- Passes: {FormatPasses(doc)}");

                var activePass = doc.ActivePass;
                if (activePass != null)
                {
                    sb.AppendLine($"- Active pass: \"{activePass.Name}\" (LightMode={activePass.LightMode})");
                    sb.AppendLine($"- Pass render state: {FormatRenderState(activePass.RenderState)}");
                    sb.AppendLine($"- Blocks in active pass: {FormatPassBlocks(activePass)}");
                    if (activePass.DataFlow != null)
                    {
                        sb.AppendLine($"- Active Attributes fields: {FormatActiveFields(activePass.DataFlow, DataFlowStage.Attributes)}");
                        sb.AppendLine($"- Active Varyings fields: {FormatActiveFields(activePass.DataFlow, DataFlowStage.Varyings)}");
                    }
                }

                if (compileErrors != null && compileErrors.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("COMPILE ERRORS IN CURRENT SHADER:");
                    foreach (var err in compileErrors)
                    {
                        sb.Append($"  - Line {err.Line}: {err.Message}");
                        if (!string.IsNullOrEmpty(err.BlockTitle))
                            sb.Append($" (in block \"{err.BlockTitle}\")");
                        sb.AppendLine();
                    }
                    sb.AppendLine();
                    sb.AppendLine("IMPORTANT: The user is likely asking you to fix these compile errors. " +
                        "Analyze the error messages and the code in the affected blocks. " +
                        "When fixing, output the corrected code for the affected block(s). " +
                        "Keep the same function signatures and AILab tags where possible.");
                }
            }

            if (!string.IsNullOrEmpty(targetContext))
            {
                sb.AppendLine();
                if (targetContext == "New Pass")
                {
                    sb.AppendLine("TARGET: Generate a COMPLETE NEW SHADER PASS. You MUST include the // [AILab_Pass: ...] tag, and provide BOTH a vertex block and a fragment block for this new pass. Follow the MULTI-PASS SUPPORT instructions above.");
                }
                else if (targetContext.StartsWith("Block:"))
                {
                    sb.AppendLine($"TARGET: You are editing an existing block. Replace its code completely. Keep the same function signature if possible.");
                }
                else if (targetContext.Contains("Vertex"))
                {
                    sb.AppendLine("TARGET: Generate a VERTEX shader function. It should modify vertex positions (inout float3 positionOS) or other vertex attributes.");
                }
                else if (targetContext.Contains("Fragment"))
                {
                    sb.AppendLine("TARGET: Generate a FRAGMENT shader function. It should compute and return a color (half4).");
                }
                else if (targetContext.Contains("Helper"))
                {
                    sb.AppendLine("TARGET: Generate a helper/utility function that can be called from vertex or fragment functions.");
                }
                else
                {
                    sb.AppendLine("TARGET: Auto-determine the best location (vertex, fragment, or helper) for the requested functionality. If the user is asking for a new render pass (e.g. outline, silhouette, second pass), generate a COMPLETE NEW SHADER PASS with the // [AILab_Pass: ...] tag.");
                }
            }

            return sb.ToString();
        }

        // ---- User Prompt ----

        public static string BuildUserPrompt(string userRequest, ShaderDocument doc, string targetContext,
            System.Collections.Generic.List<Core.ShaderCompileChecker.CompileError> compileErrors = null)
        {
            var sb = new StringBuilder();

            if (targetContext != null && targetContext.StartsWith("Block:"))
            {
                string blockTitle = targetContext.Substring(7).Trim();
                var block = doc?.FindBlockByTitle(blockTitle);
                if (block != null)
                {
                    sb.AppendLine("EXISTING CODE IN THIS BLOCK:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(block.Code);
                    sb.AppendLine("```");
                    sb.AppendLine();
                    sb.AppendLine("MODIFICATION REQUEST:");
                }
            }

            if (compileErrors != null && compileErrors.Count > 0)
            {
                var errorBlockIds = new System.Collections.Generic.HashSet<string>();
                foreach (var err in compileErrors)
                {
                    if (!string.IsNullOrEmpty(err.BlockId))
                        errorBlockIds.Add(err.BlockId);
                }

                if (errorBlockIds.Count > 0 && doc != null)
                {
                    sb.AppendLine("CODE IN BLOCKS WITH ERRORS:");
                    foreach (string blockId in errorBlockIds)
                    {
                        var block = doc.FindBlockById(blockId);
                        if (block == null) continue;
                        sb.AppendLine($"--- Block: \"{block.Title}\" (Section: {block.Section}) ---");
                        sb.AppendLine("```hlsl");
                        sb.AppendLine(block.Code);
                        sb.AppendLine("```");
                        sb.AppendLine();
                    }
                }
                else if (doc != null && !string.IsNullOrEmpty(doc.RawContent))
                {
                    int errorLine = compileErrors[0].Line;
                    string[] lines = doc.RawContent.Split('\n');
                    int start = System.Math.Max(0, errorLine - 10);
                    int end = System.Math.Min(lines.Length - 1, errorLine + 10);
                    sb.AppendLine($"SHADER CODE AROUND ERROR (lines {start + 1}-{end + 1}):");
                    sb.AppendLine("```hlsl");
                    for (int i = start; i <= end; i++)
                        sb.AppendLine($"/* L{i + 1} */ {lines[i].TrimEnd('\r')}");
                    sb.AppendLine("```");
                    sb.AppendLine();
                }
            }

            sb.AppendLine(userRequest);

            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code with AILab tags. If you need new properties, include their declarations. Wrap your code in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Response Parsing ----

        static readonly Regex ReCodeBlock = new Regex(
            @"```(?:hlsl|glsl|shader|c)?\s*\n([\s\S]*?)```",
            RegexOptions.Compiled);

        static readonly Regex RePropertyTag = new Regex(
            @"//\s*\[AILab_Property:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReBlockStartTag = new Regex(
            @"//\s*\[AILab_Block_Start:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReBlockEndTag = new Regex(
            @"//\s*\[AILab_Block_End\]", RegexOptions.Compiled);

        static readonly Regex ReIntentTag = new Regex(
            @"//\s*\[AILab_Intent:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex ReParamTag = new Regex(
            @"//\s*\[AILab_Param:\s*""([^""]+)""\s+role=""([^""]*)""\]", RegexOptions.Compiled);

        static readonly Regex ReSectionTag = new Regex(
            @"//\s*\[AILab_Section:\s*""([^""]+)""\]", RegexOptions.Compiled);

        static readonly Regex RePassTag = new Regex(
            @"//\s*\[AILab_Pass:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex RePassStateTag = new Regex(
            @"//\s*\[AILab_PassState:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReStencilTag = new Regex(
            @"//\s*\[AILab_Stencil:\s*(.*?)\]", RegexOptions.Compiled);

        static readonly Regex ReKV = new Regex(
            @"(\w+)=""([^""]*?)""", RegexOptions.Compiled);

        /// <summary>
        /// Extract clean HLSL code from an LLM response that may contain markdown formatting.
        /// </summary>
        public static string ExtractCodeFromResponse(string response)
        {
            if (string.IsNullOrEmpty(response)) return response;

            var match = ReCodeBlock.Match(response);
            if (match.Success)
                return match.Groups[1].Value.Trim();

            string trimmed = response.Trim();
            if (trimmed.StartsWith("//") || trimmed.StartsWith("void") ||
                trimmed.StartsWith("half") || trimmed.StartsWith("float") ||
                trimmed.StartsWith("struct") || trimmed.StartsWith("CBUFFER") ||
                trimmed.StartsWith("// [AILab"))
            {
                return trimmed;
            }

            return trimmed;
        }

        /// <summary>
        /// Result of parsing a full LLM response: extracted properties, blocks, and
        /// any leftover code that wasn't inside a block tag.
        /// </summary>
        public class ParsedLLMResponse
        {
            public List<ShaderProperty> Properties = new List<ShaderProperty>();
            public List<ParsedBlock> Blocks = new List<ParsedBlock>();
            public string LeftoverCode = "";
            public ParsedPassInfo PassInfo;
        }

        public class ParsedBlock
        {
            public string Title;
            public string Intent;
            public string Code;
            public ShaderSectionType Section;
            public List<string> ReferencedParams = new List<string>();
        }

        public class ParsedPassInfo
        {
            public string Name;
            public string LightMode;
            public string CullOverride;
            public string BlendOverride;
            public string ZWriteOverride;
            public string ZTestOverride;
            public string ColorMaskOverride;
            public StencilState StencilOverride;
        }

        /// <summary>
        /// Parse the full LLM response to extract all properties, blocks with
        /// proper titles, and section information.
        /// </summary>
        public static ParsedLLMResponse ParseFullResponse(string response, ShaderSectionType defaultSection)
        {
            var result = new ParsedLLMResponse();
            string code = ExtractCodeFromResponse(response);
            if (string.IsNullOrEmpty(code)) return result;

            string[] lines = code.Split(new[] { "\r\n", "\n" }, System.StringSplitOptions.None);

            // Track which lines belong to blocks vs leftover
            bool[] consumed = new bool[lines.Length];
            ShaderSectionType currentSection = defaultSection;

            // 1) Extract properties (and their Unity declaration on the next line)
            for (int i = 0; i < lines.Length; i++)
            {
                var pm = RePropertyTag.Match(lines[i]);
                if (!pm.Success) continue;

                var prop = new ShaderProperty();
                foreach (Match kv in ReKV.Matches(pm.Groups[1].Value))
                {
                    string key = kv.Groups[1].Value.ToLowerInvariant();
                    string val = kv.Groups[2].Value;
                    switch (key)
                    {
                        case "name":       prop.Name           = val; break;
                        case "display":    prop.DisplayName    = val; break;
                        case "type":       prop.PropertyType   = ParsePropertyType(val); break;
                        case "default":    prop.DefaultValue   = val; break;
                        case "min":        if (float.TryParse(val, out float mn)) prop.MinValue = mn; break;
                        case "max":        if (float.TryParse(val, out float mx)) prop.MaxValue = mx; break;
                        case "role":       prop.Role           = val; break;
                        case "defaulttex": prop.DefaultTexture = val; break;
                    }
                }

                consumed[i] = true;

                // Check next non-empty line for raw Unity declaration
                for (int j = i + 1; j < lines.Length && j <= i + 3; j++)
                {
                    string trimmed = lines[j].Trim();
                    if (string.IsNullOrEmpty(trimmed)) continue;
                    if (trimmed.StartsWith("//")) continue;
                    // Looks like a Unity property declaration (e.g. _Foo("Bar", Float) = 0)
                    if (trimmed.StartsWith("_") && trimmed.Contains("("))
                    {
                        prop.RawDeclaration = trimmed;
                        consumed[j] = true;
                    }
                    break;
                }

                if (!string.IsNullOrEmpty(prop.Name))
                    result.Properties.Add(prop);
            }

            // 1.5) Detect AILab_Pass and AILab_PassState tags
            for (int i = 0; i < lines.Length; i++)
            {
                var passMatch = RePassTag.Match(lines[i]);
                if (passMatch.Success)
                {
                    result.PassInfo = new ParsedPassInfo();
                    foreach (Match kv in ReKV.Matches(passMatch.Groups[1].Value))
                    {
                        string key = kv.Groups[1].Value.ToLowerInvariant();
                        string val = kv.Groups[2].Value;
                        switch (key)
                        {
                            case "name": result.PassInfo.Name = val; break;
                            case "lightmode": result.PassInfo.LightMode = val; break;
                        }
                    }
                    consumed[i] = true;
                }

                var stateMatch = RePassStateTag.Match(lines[i]);
                if (stateMatch.Success)
                {
                    if (result.PassInfo == null) result.PassInfo = new ParsedPassInfo();
                    foreach (Match kv in ReKV.Matches(stateMatch.Groups[1].Value))
                    {
                        string key = kv.Groups[1].Value.ToLowerInvariant();
                        string val = kv.Groups[2].Value;
                        switch (key)
                        {
                            case "cull": result.PassInfo.CullOverride = val; break;
                            case "blend": result.PassInfo.BlendOverride = val; break;
                            case "zwrite": result.PassInfo.ZWriteOverride = val; break;
                            case "ztest": result.PassInfo.ZTestOverride = val; break;
                            case "colormask": result.PassInfo.ColorMaskOverride = val; break;
                        }
                    }
                    consumed[i] = true;
                }

                var stencilMatch = ReStencilTag.Match(lines[i]);
                if (stencilMatch.Success)
                {
                    if (result.PassInfo == null) result.PassInfo = new ParsedPassInfo();
                    var st = new StencilState();
                    foreach (Match kv in ReKV.Matches(stencilMatch.Groups[1].Value))
                    {
                        string key = kv.Groups[1].Value.ToLowerInvariant();
                        string val = kv.Groups[2].Value;
                        switch (key)
                        {
                            case "ref":       if (int.TryParse(val, out int r)) st.Ref = r; break;
                            case "comp":      st.Comp = val; break;
                            case "pass":      st.Pass = val; break;
                            case "fail":      st.Fail = val; break;
                            case "zfail":     st.ZFail = val; break;
                            case "readmask":  if (int.TryParse(val, out int rm)) st.ReadMask = rm; break;
                            case "writemask": if (int.TryParse(val, out int wm)) st.WriteMask = wm; break;
                        }
                    }
                    result.PassInfo.StencilOverride = st;
                    consumed[i] = true;
                }
            }

            // 2) Extract blocks defined by AILab_Block_Start / AILab_Block_End
            int idx = 0;
            while (idx < lines.Length)
            {
                // Track section changes
                var secMatch = ReSectionTag.Match(lines[idx]);
                if (secMatch.Success)
                {
                    string secName = secMatch.Groups[1].Value.ToLowerInvariant();
                    if (secName.Contains("vertex")) currentSection = ShaderSectionType.Vertex;
                    else if (secName.Contains("fragment")) currentSection = ShaderSectionType.Fragment;
                    else if (secName.Contains("helper")) currentSection = ShaderSectionType.Helper;
                    else if (secName.Contains("constant")) currentSection = ShaderSectionType.Constants;
                    consumed[idx] = true;
                    idx++;
                    continue;
                }

                var bsm = ReBlockStartTag.Match(lines[idx]);
                if (!bsm.Success) { idx++; continue; }

                consumed[idx] = true;
                var parsedBlock = new ParsedBlock
                {
                    Title = bsm.Groups[1].Value,
                    Section = currentSection
                };

                var codeLines = new List<string>();
                idx++;

                while (idx < lines.Length)
                {
                    if (ReBlockEndTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        break;
                    }

                    var im = ReIntentTag.Match(lines[idx]);
                    if (im.Success)
                    {
                        parsedBlock.Intent = im.Groups[1].Value;
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    var prm = ReParamTag.Match(lines[idx]);
                    if (prm.Success)
                    {
                        parsedBlock.ReferencedParams.Add(prm.Groups[1].Value);
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    // Skip property lines inside blocks
                    if (RePropertyTag.IsMatch(lines[idx]))
                    {
                        consumed[idx] = true;
                        idx++;
                        continue;
                    }

                    if (!consumed[idx])
                        codeLines.Add(lines[idx]);
                    consumed[idx] = true;
                    idx++;
                }

                parsedBlock.Code = DedentParsedLines(codeLines);
                result.Blocks.Add(parsedBlock);
            }

            // 3) Leftover code (not inside any block tags and not property declarations)
            var leftover = new List<string>();
            for (int i = 0; i < lines.Length; i++)
            {
                if (!consumed[i]) leftover.Add(lines[i]);
            }
            result.LeftoverCode = DedentParsedLines(leftover);

            return result;
        }

        static string DedentParsedLines(List<string> lines)
        {
            if (lines.Count == 0) return "";

            int minIndent = int.MaxValue;
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) continue;
                int spaces = 0;
                foreach (char c in line)
                {
                    if (c == ' ') spaces++;
                    else if (c == '\t') spaces += 4;
                    else break;
                }
                if (spaces < minIndent) minIndent = spaces;
            }

            if (minIndent <= 0 || minIndent == int.MaxValue)
                return string.Join("\n", lines).Trim();

            var result = new List<string>();
            foreach (string raw in lines)
            {
                string line = raw.TrimEnd('\r');
                if (string.IsNullOrWhiteSpace(line)) { result.Add(""); continue; }
                int removed = 0, i = 0;
                while (removed < minIndent && i < line.Length)
                {
                    if (line[i] == ' ') { removed++; i++; }
                    else if (line[i] == '\t') { removed += 4; i++; }
                    else break;
                }
                result.Add(line.Substring(i));
            }
            return string.Join("\n", result).Trim();
        }

        static ShaderPropertyType ParsePropertyType(string raw)
        {
            switch (raw.ToLowerInvariant())
            {
                case "float":     return ShaderPropertyType.Float;
                case "range":     return ShaderPropertyType.Range;
                case "color":     return ShaderPropertyType.Color;
                case "vector":    return ShaderPropertyType.Vector;
                case "2d":
                case "texture2d": return ShaderPropertyType.Texture2D;
                case "3d":
                case "texture3d": return ShaderPropertyType.Texture3D;
                case "cube":
                case "cubemap":   return ShaderPropertyType.Cubemap;
                case "int":
                case "integer":   return ShaderPropertyType.Int;
                default:          return ShaderPropertyType.Float;
            }
        }

        // ---- Inline Insert Prompt ----

        public static string BuildInlineInsertPrompt(string blockCode, int cursorPosition, string userRequest)
        {
            var sb = new StringBuilder();
            sb.AppendLine("INLINE CODE INSERTION REQUEST");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(blockCode))
            {
                string before = cursorPosition > 0 && cursorPosition <= blockCode.Length
                    ? blockCode.Substring(0, cursorPosition) : blockCode;
                string after = cursorPosition >= 0 && cursorPosition < blockCode.Length
                    ? blockCode.Substring(cursorPosition) : "";

                sb.AppendLine("CODE BEFORE CURSOR:");
                sb.AppendLine("```hlsl");
                sb.AppendLine(before);
                sb.AppendLine("```");
                sb.AppendLine();

                if (!string.IsNullOrEmpty(after.Trim()))
                {
                    sb.AppendLine("CODE AFTER CURSOR:");
                    sb.AppendLine("```hlsl");
                    sb.AppendLine(after);
                    sb.AppendLine("```");
                    sb.AppendLine();
                }
            }

            sb.AppendLine($"INSERT REQUEST: {userRequest}");
            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code snippet to insert at the cursor position. No surrounding function signatures or existing code. Just the new lines to insert. Wrap in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Data Flow Prompts ----

        const string DataFlowSystemPrompt = @"You are an expert in Unity URP shader development.
Your task is to determine which vertex input (Attributes/a2v) and fragment input (Varyings/v2f) fields are needed to implement a described visual effect.

Available Attributes fields: positionOS, normalOS, tangentOS, uv, uv2, color
Available Varyings fields: positionCS, normalWS, tangentWS, bitangentWS, uv, positionWS, viewDirWS, fogFactor, shadowCoord, vertexColor, screenPos

Global uniforms (always available, no struct needed): _Time, _SinTime, _CosTime, unity_DeltaTime, _WorldSpaceCameraPos, _ScreenParams
Textures/Samplers: declared automatically from shader Properties (need UV in Varyings to sample them)

Dependencies (Varyings field requires Attributes field):
- positionCS requires positionOS
- positionWS requires positionOS
- normalWS requires normalOS
- tangentWS requires tangentOS
- bitangentWS requires normalOS + tangentOS
- uv requires uv
- fogFactor requires positionOS
- shadowCoord requires positionOS
- viewDirWS requires positionOS
- vertexColor requires color
- screenPos requires positionOS

RULES:
1. positionCS is always required and always active - do not include it in your response.
2. positionOS is always required and always active - do not include it in your response.
3. Only list Varyings fields that need to be ACTIVATED for the requested effect.
4. If the effect needs texture sampling, include ""uv"" in activate_varyings.
5. Global uniforms like _Time are always available; do NOT include them in activate_varyings.
6. If the user asks about render state settings (depth, stencil, blend, cull, color mask), include a ""render_state"" object.
   Supported keys: cull (Back/Front/Off), blend (e.g. ""SrcAlpha OneMinusSrcAlpha""), zwrite (On/Off),
   ztest (LEqual/Less/Equal/GEqual/Greater/NotEqual/Always), colormask (RGBA/RGB/R/G/B/A/0),
   stencil (object with ref/comp/pass/fail/zfail/readmask/writemask).
   Only include keys that need to CHANGE. Omit keys that should stay at defaults.
7. Respond in EXACTLY this JSON format, nothing else:

{
  ""activate_varyings"": [""fieldName1"", ""fieldName2""],
  ""annotations"": {
    ""fieldName1"": ""Brief reason this field is needed"",
    ""fieldName2"": ""Brief reason this field is needed""
  },
  ""render_state"": {
    ""cull"": ""Back"",
    ""ztest"": ""LEqual"",
    ""stencil"": { ""ref"": 1, ""comp"": ""Always"", ""pass"": ""Replace"" }
  }
}

The annotations should explain WHY each field is needed in the context of the user's request.
Only activate Varyings fields; their Attributes dependencies will be auto-resolved.
The render_state object is OPTIONAL - only include it if the user asks about render settings.";

        public static string BuildDataFlowSystemPrompt(ShaderDocument doc)
        {
            var sb = new StringBuilder(DataFlowSystemPrompt);
            if (doc != null)
            {
                var dataFlow = doc.ActivePass?.DataFlow;
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine($"CURRENT STATE:");
                if (doc.ActivePass != null)
                {
                    sb.AppendLine($"- Active pass: \"{doc.ActivePass.Name}\" (LightMode={doc.ActivePass.LightMode})");
                    sb.AppendLine($"- Pass render state: {FormatRenderState(doc.ActivePass.RenderState)}");
                }
                if (dataFlow != null)
                {
                    sb.AppendLine($"- Active Attributes: {FormatActiveFields(dataFlow, DataFlowStage.Attributes)}");
                    sb.AppendLine($"- Active Varyings: {FormatActiveFields(dataFlow, DataFlowStage.Varyings)}");
                }
            }
            return sb.ToString();
        }

        public static string BuildDataFlowUserPrompt(string userRequest)
        {
            return $"USER REQUEST: {userRequest}\n\nDetermine which Varyings fields to activate and provide annotations. Respond ONLY with the JSON.";
        }

        static readonly Regex ReJsonBlock = new Regex(
            @"\{[\s\S]*""activate_varyings""[\s\S]*\}",
            RegexOptions.Compiled);

        static readonly Regex ReFieldArray = new Regex(
            @"""activate_varyings""\s*:\s*\[(.*?)\]",
            RegexOptions.Compiled | RegexOptions.Singleline);

        static readonly Regex ReAnnotation = new Regex(
            @"""(\w+)""\s*:\s*""([^""]+)""",
            RegexOptions.Compiled);

        /// <summary>
        /// Parse the LLM's JSON response for Data Flow field activation.
        /// Returns (list of varying field names to activate, dict of annotations).
        /// </summary>
        public static (List<string> fields, Dictionary<string, string> annotations, PassRenderState renderState) ParseDataFlowResponse(string response)
        {
            var fields = new List<string>();
            var annotations = new Dictionary<string, string>();
            PassRenderState renderState = null;

            if (string.IsNullOrEmpty(response))
                return (fields, annotations, null);

            string json = response;
            var codeMatch = ReCodeBlock.Match(response);
            if (codeMatch.Success)
                json = codeMatch.Groups[1].Value;

            var jsonMatch = ReJsonBlock.Match(json);
            if (jsonMatch.Success)
                json = jsonMatch.Value;

            var arrMatch = ReFieldArray.Match(json);
            if (arrMatch.Success)
            {
                var items = Regex.Matches(arrMatch.Groups[1].Value, @"""(\w+)""");
                foreach (Match m in items)
                    fields.Add(m.Groups[1].Value);
            }

            var annotSection = Regex.Match(json, @"""annotations""\s*:\s*\{([\s\S]*?)\}", RegexOptions.Singleline);
            if (annotSection.Success)
            {
                foreach (Match am in ReAnnotation.Matches(annotSection.Groups[1].Value))
                    annotations[am.Groups[1].Value] = am.Groups[2].Value;
            }

            var rsSection = Regex.Match(json, @"""render_state""\s*:\s*\{([\s\S]*?)\}", RegexOptions.Singleline);
            if (rsSection.Success)
            {
                renderState = new PassRenderState();
                string rsBody = rsSection.Value;

                var simpleKV = new Regex(@"""(cull|blend|zwrite|ztest|colormask)""\s*:\s*""([^""]+)""", RegexOptions.IgnoreCase);
                foreach (Match m in simpleKV.Matches(rsBody))
                {
                    switch (m.Groups[1].Value.ToLowerInvariant())
                    {
                        case "cull":      renderState.CullMode = m.Groups[2].Value; break;
                        case "blend":     renderState.BlendMode = m.Groups[2].Value; break;
                        case "zwrite":    renderState.ZWriteMode = m.Groups[2].Value; break;
                        case "ztest":     renderState.ZTestMode = m.Groups[2].Value; break;
                        case "colormask": renderState.ColorMask = m.Groups[2].Value; break;
                    }
                }

                var stencilSection = Regex.Match(rsBody, @"""stencil""\s*:\s*\{([\s\S]*?)\}", RegexOptions.Singleline);
                if (stencilSection.Success)
                {
                    var st = new StencilState();
                    var stKV = new Regex(@"""(\w+)""\s*:\s*(?:""([^""]+)""|(\d+))");
                    foreach (Match m in stKV.Matches(stencilSection.Groups[1].Value))
                    {
                        string key = m.Groups[1].Value.ToLowerInvariant();
                        string strVal = !string.IsNullOrEmpty(m.Groups[2].Value) ? m.Groups[2].Value : m.Groups[3].Value;
                        switch (key)
                        {
                            case "ref":       if (int.TryParse(strVal, out int r)) st.Ref = r; break;
                            case "comp":      st.Comp = strVal; break;
                            case "pass":      st.Pass = strVal; break;
                            case "fail":      st.Fail = strVal; break;
                            case "zfail":     st.ZFail = strVal; break;
                            case "readmask":  if (int.TryParse(strVal, out int rm)) st.ReadMask = rm; break;
                            case "writemask": if (int.TryParse(strVal, out int wm)) st.WriteMask = wm; break;
                        }
                    }
                    renderState.Stencil = st;
                }
            }

            return (fields, annotations, renderState);
        }

        // ---- Helpers ----

        static string FormatProperties(ShaderDocument doc)
        {
            if (doc.Properties.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var p in doc.Properties)
                sb.Append($"{p.Name}({p.PropertyType}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatPasses(ShaderDocument doc)
        {
            if (doc.Passes.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var p in doc.Passes)
            {
                if (p.IsUsePass)
                    sb.Append($"[UsePass:\"{p.UsePassPath}\"], ");
                else
                    sb.Append($"\"{p.Name}\"(LightMode={p.LightMode}), ");
            }
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatPassBlocks(ShaderPass pass)
        {
            if (pass == null || pass.Blocks.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var b in pass.Blocks)
                sb.Append($"\"{b.Title}\"({b.Section}), ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatActiveFields(DataFlowGraph graph, DataFlowStage stage)
        {
            if (graph == null) return "(none)";
            var active = graph.GetActiveFields(stage);
            if (active.Count == 0) return "(none)";
            var sb = new StringBuilder();
            foreach (var f in active)
                sb.Append($"{f.Name}, ");
            return sb.ToString().TrimEnd(',', ' ');
        }

        static string FormatRenderState(PassRenderState rs)
        {
            if (rs == null || !rs.HasOverrides) return "(defaults)";
            var sb = new StringBuilder();
            if (!string.IsNullOrEmpty(rs.CullMode)) sb.Append($"Cull={rs.CullMode} ");
            if (!string.IsNullOrEmpty(rs.BlendMode)) sb.Append($"Blend={rs.BlendMode} ");
            if (!string.IsNullOrEmpty(rs.ZWriteMode)) sb.Append($"ZWrite={rs.ZWriteMode} ");
            if (!string.IsNullOrEmpty(rs.ZTestMode)) sb.Append($"ZTest={rs.ZTestMode} ");
            if (!string.IsNullOrEmpty(rs.ColorMask)) sb.Append($"ColorMask={rs.ColorMask} ");
            if (rs.Stencil != null && rs.Stencil.HasOverrides)
                sb.Append($"Stencil(Ref={rs.Stencil.Ref} Comp={rs.Stencil.Comp} Pass={rs.Stencil.Pass}) ");
            return sb.ToString().Trim();
        }

        // ---- Material Parameter Adjustment Prompts ----

        public static string BuildMaterialAdjustSystemPrompt()
        {
            return @"You are an assistant that adjusts Unity material property values based on natural language instructions.

RULES:
1. Output ONLY a JSON object mapping property names to their new string values.
2. For Float/Range properties, output a plain number string like ""0.5"".
3. For Color properties, output ""(r,g,b,a)"" with values in 0-1 range.
4. For Vector properties, output ""(x,y,z,w)"".
5. For Int properties, output a plain integer string like ""2"".
6. Do NOT include texture properties — they cannot be adjusted via text.
7. Only include properties whose values you are changing. Omit unchanged properties.
8. Respect Min/Max ranges for Range properties.
9. No markdown, no explanation — just the JSON object.

Example output:
{""_BaseColor"": ""(1,0.9,0.85,1)"", ""_Smoothness"": ""0.6""}";
        }

        public static string BuildMaterialAdjustUserPrompt(
            string userRequest,
            UnityEditor.MaterialProperty[] properties,
            Dictionary<string, PropertyMeta> metaCache)
        {
            var sb = new StringBuilder();
            sb.AppendLine("CURRENT MATERIAL PROPERTIES:");
            sb.AppendLine();

            foreach (var prop in properties)
            {
                if ((prop.flags & UnityEditor.MaterialProperty.PropFlags.HideInInspector) != 0)
                    continue;
                if (prop.type == UnityEditor.MaterialProperty.PropType.Texture)
                    continue;

                string display = prop.displayName;
                string role = "";
                if (metaCache != null && metaCache.TryGetValue(prop.name, out var meta))
                {
                    if (!string.IsNullOrEmpty(meta.DisplayName)) display = meta.DisplayName;
                    role = meta.Role ?? "";
                }

                string currentVal = FormatMaterialPropertyValue(prop);
                string rangeInfo = "";
                if (prop.type == UnityEditor.MaterialProperty.PropType.Range)
                    rangeInfo = $" [range: {prop.rangeLimits.x} ~ {prop.rangeLimits.y}]";

                sb.AppendLine($"- {prop.name} (\"{display}\", {prop.type}{rangeInfo}): {currentVal}  role=\"{role}\"");
            }

            sb.AppendLine();
            sb.AppendLine($"USER INSTRUCTION: {userRequest}");
            sb.AppendLine();
            sb.AppendLine("Output ONLY the JSON object with changed properties.");

            return sb.ToString();
        }

        static string FormatMaterialPropertyValue(UnityEditor.MaterialProperty prop)
        {
            switch (prop.type)
            {
                case UnityEditor.MaterialProperty.PropType.Float:
                case UnityEditor.MaterialProperty.PropType.Range:
                    return prop.floatValue.ToString("F3");
                case UnityEditor.MaterialProperty.PropType.Color:
                    var c = prop.colorValue;
                    return $"({c.r:F3},{c.g:F3},{c.b:F3},{c.a:F3})";
                case UnityEditor.MaterialProperty.PropType.Vector:
                    var v = prop.vectorValue;
                    return $"({v.x:F3},{v.y:F3},{v.z:F3},{v.w:F3})";
#if UNITY_2021_1_OR_NEWER
                case UnityEditor.MaterialProperty.PropType.Int:
                    return prop.intValue.ToString();
#endif
                default:
                    return "(unsupported)";
            }
        }

        static readonly Regex ReJsonObject = new Regex(
            @"\{[\s\S]*?\}", RegexOptions.Compiled);
        static readonly Regex ReJsonKV = new Regex(
            @"""([^""]+)""\s*:\s*""([^""]+)""", RegexOptions.Compiled);

        public static Dictionary<string, string> ParseMaterialAdjustResponse(string response)
        {
            var result = new Dictionary<string, string>();
            if (string.IsNullOrEmpty(response)) return result;

            var codeMatch = ReCodeBlock.Match(response);
            string json = codeMatch.Success ? codeMatch.Groups[1].Value : response;

            var objMatch = ReJsonObject.Match(json);
            if (!objMatch.Success) return result;

            foreach (Match kv in ReJsonKV.Matches(objMatch.Value))
                result[kv.Groups[1].Value] = kv.Groups[2].Value;

            return result;
        }

        // ====================================================================
        //  Plan Prompts
        // ====================================================================

        const string PlanDecompositionSystemPrompt = @"You are an expert shader technical consultant for Unity URP.
Your task is to decompose a user's visual effect request into a structured, step-by-step shader development plan.

You MUST return a valid JSON object with the following structure. Output ONLY the JSON, no markdown fences, no explanation text.

The plan must cover these phases (include ALL of them, even if a phase has minimal content):

1. VisualAnalysis - Analyze the key visual characteristics of the requested effect. Identify common implementation techniques. Reference well-known shaders or papers if applicable.
2. DataFlow - Determine which Attributes (a2v) and Varyings (v2f) fields are needed. Available Attributes: positionOS, normalOS, tangentOS, uv, uv2, color. Available Varyings: positionCS, normalWS, tangentWS, bitangentWS, uv, positionWS, viewDirWS, fogFactor, shadowCoord, vertexColor, screenPos.
3. Textures - List all textures and resources needed (ramp textures, normal maps, noise textures, etc.). For each, suggest whether the user should provide it, or if it can be procedurally generated in shader, or if an AI image generation model could create it (note: AI generation capability may be limited).
4. VertexShader - Describe vertex processing steps needed (vertex displacement, normal modification, etc.). If no vertex modification is needed, state that the default vertex transform suffices.
5. FragmentShader - Break down the fragment shader into logical steps/blocks. Each step should be a self-contained function. This is typically the most detailed phase.
6. ShaderOptions - Specify render state: Cull mode, Blend mode, ZWrite, ZTest, ColorMask, Stencil settings, RenderQueue, RenderType. Only include non-default values.
7. MultiPass - If multiple passes are needed (e.g., outline pass, shadow caster, depth-only), describe each additional pass and its purpose. If single pass suffices, state so.

JSON SCHEMA:
{
  ""phases"": [
    {
      ""type"": ""VisualAnalysis"" | ""DataFlow"" | ""Textures"" | ""VertexShader"" | ""FragmentShader"" | ""ShaderOptions"" | ""MultiPass"",
      ""title"": ""Short descriptive title"",
      ""proposal"": ""Detailed analysis and recommendations (can be multiple paragraphs)"",
      ""question"": ""Optional question to ask the user for clarification (or empty string if none)"",
      ""items"": [
        {
          ""key"": ""unique_identifier"",
          ""description"": ""Short description"",
          ""detail"": ""More detail about implementation"",
          ""category"": ""Optional grouping category""
        }
      ]
    }
  ]
}

IMPORTANT RULES:
- The ""phases"" array MUST contain exactly 7 objects, one for each phase type, in the order listed above.
- Each phase MUST have at least one item in its ""items"" array.
- The ""proposal"" should be detailed and actionable, explaining WHY certain choices are made.
- For FragmentShader phase, break the effect into small, composable function blocks (e.g., ""Base Color Sampling"", ""Normal Mapping"", ""Lighting Calculation"", ""Rim Light"", ""Final Composition"").
- For DataFlow phase, items should use field names as keys (e.g., ""normalWS"", ""viewDirWS"") with category ""Attributes"" or ""Varyings"".
- For Textures phase, items should use property names as keys (e.g., ""_RampTex"", ""_NormalMap"") with category indicating source (""User Provided"", ""Procedural"", ""AI Generated"").
- Ask clarifying questions when the user's request is ambiguous about specific visual details.";

        public static string BuildPlanDecompositionSystemPrompt(ShaderDocument doc)
        {
            var sb = new StringBuilder(PlanDecompositionSystemPrompt);

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Render settings: Cull={doc.GlobalSettings.CullMode}, Blend={doc.GlobalSettings.BlendMode}, ZWrite={doc.GlobalSettings.ZWriteMode}");
                sb.AppendLine($"- Passes: {FormatPasses(doc)}");

                var activePass = doc.ActivePass;
                if (activePass != null)
                {
                    sb.AppendLine($"- Active pass: \"{activePass.Name}\" (LightMode={activePass.LightMode})");
                    sb.AppendLine($"- Blocks in active pass: {FormatPassBlocks(activePass)}");
                }
            }

            return sb.ToString();
        }

        public static string BuildPlanDecompositionUserPrompt(string userRequest)
        {
            return $"USER REQUEST: {userRequest}\n\nDecompose this into a complete shader development plan. Return ONLY the JSON object.";
        }

        const string PhaseRefinementSystemPrompt = @"You are an expert shader technical consultant for Unity URP.
The user is refining one phase of a shader development plan based on their feedback.

You must return a valid JSON object representing the UPDATED phase. Output ONLY the JSON, no markdown fences.

JSON SCHEMA (single phase):
{
  ""type"": ""<same phase type>"",
  ""title"": ""<updated or same title>"",
  ""proposal"": ""<updated analysis incorporating user feedback>"",
  ""question"": ""<follow-up question if needed, or empty string>"",
  ""items"": [
    {
      ""key"": ""unique_identifier"",
      ""description"": ""Short description"",
      ""detail"": ""Implementation detail"",
      ""category"": ""Optional grouping""
    }
  ]
}

RULES:
- Incorporate the user's feedback into the proposal and items.
- Keep items that the user did not object to.
- Add or remove items based on feedback.
- If the user answered a question, reflect their answer in the updated proposal.
- You may ask a new follow-up question if needed.";

        public static string BuildPhaseRefinementSystemPrompt(ShaderPlan plan, PlanPhase phase)
        {
            var sb = new StringBuilder(PhaseRefinementSystemPrompt);

            sb.AppendLine();
            sb.AppendLine();
            sb.AppendLine($"ORIGINAL USER REQUEST: {plan.UserRequest}");
            sb.AppendLine();
            sb.AppendLine("FULL PLAN CONTEXT (all phases):");

            foreach (var p in plan.Phases)
            {
                string status = p.IsTerminal ? "(confirmed)" : "(pending)";
                sb.AppendLine($"- {ShaderPlan.GetPhaseTypeLabel(p.Type)} {status}: {Truncate(p.LLMProposal, 200)}");
            }

            sb.AppendLine();
            sb.AppendLine($"PHASE BEING REFINED: {phase.Title} ({phase.Type})");
            sb.AppendLine($"CURRENT PROPOSAL:\n{phase.LLMProposal}");

            if (phase.Items != null && phase.Items.Count > 0)
            {
                sb.AppendLine("CURRENT ITEMS:");
                foreach (var item in phase.Items)
                    sb.AppendLine($"  - {item.Key}: {item.Description} ({item.Detail})");
            }

            sb.AppendLine($"REFINEMENT COUNT: {phase.RefinementCount}");

            return sb.ToString();
        }

        public static string BuildPhaseRefinementUserPrompt(string userFeedback)
        {
            return $"USER FEEDBACK: {userFeedback}\n\nUpdate this phase based on the feedback. Return ONLY the updated phase JSON object.";
        }

        public static string BuildPlanExecutionSystemPrompt(ShaderPlan plan, PlanPhaseType targetPhase, ShaderDocument doc)
        {
            var sb = new StringBuilder(CoreSystemPrompt);

            sb.AppendLine();
            sb.AppendLine();
            sb.AppendLine("=== PLAN EXECUTION MODE ===");
            sb.AppendLine("You are executing a pre-planned shader development step. Generate code that precisely follows the plan.");
            sb.AppendLine();
            sb.AppendLine($"ORIGINAL USER REQUEST: {plan.UserRequest}");
            sb.AppendLine();
            sb.AppendLine("CONFIRMED PLAN PHASES:");

            foreach (var phase in plan.Phases)
            {
                if (!phase.IsTerminal) continue;
                sb.AppendLine($"\n--- {ShaderPlan.GetPhaseTypeLabel(phase.Type)} ---");
                sb.AppendLine(phase.LLMProposal);
                if (phase.Items != null)
                {
                    foreach (var item in phase.Items)
                    {
                        if (item.IsConfirmed || phase.Status == PhaseStatus.Confirmed)
                            sb.AppendLine($"  * {item.Key}: {item.Description} - {item.Detail}");
                    }
                }
            }

            sb.AppendLine();

            sb.AppendLine("CRITICAL FRAMEWORK CONSTRAINTS:");
            sb.AppendLine("- The framework auto-generates vert() and frag() entry points. You MUST NOT generate vert() or frag() functions.");
            sb.AppendLine("- Vertex blocks: MUST use signature `void FuncName(inout float3 positionOS)` with exactly ONE parameter.");
            sb.AppendLine("  The framework will call your function with the object-space position. Use input.normalOS for normals via `Attributes input` if needed in the block code, but the function signature MUST be `(inout float3)`.");
            sb.AppendLine("- Fragment blocks that are helper/utility functions (called by other fragment functions) MUST use `// [AILab_Section: \"Helper Functions\"]` tag.");
            sb.AppendLine("- Only the FINAL composition fragment function should use `// [AILab_Section: \"Fragment\"]`. This function will be auto-called by the framework.");
            sb.AppendLine("- The final fragment function MUST have signature `half4 FuncName(Varyings input)` with exactly ONE parameter.");
            sb.AppendLine("- If you need URP lighting (GetMainLight, Light struct), the framework will auto-detect and add Lighting.hlsl. Just use the API freely.");
            sb.AppendLine("- Each pass has its own scope. Functions from one pass are NOT visible in another pass.");
            sb.AppendLine();

            switch (targetPhase)
            {
                case PlanPhaseType.VertexShader:
                    sb.AppendLine("TARGET: Generate the VERTEX shader block(s) for the MAIN pass.");
                    sb.AppendLine("Each vertex block: `void FuncName(inout float3 positionOS)` — one parameter only.");
                    sb.AppendLine("Use `// [AILab_Section: \"Vertex\"]` tag.");
                    break;
                case PlanPhaseType.FragmentShader:
                    sb.AppendLine("TARGET: Generate the fragment shader logic for the MAIN pass.");
                    sb.AppendLine("Structure: helper functions (Section: \"Helper Functions\") + ONE final composition function (Section: \"Fragment\").");
                    sb.AppendLine("The composition function calls the helpers and returns `half4`.");
                    sb.AppendLine("Helper functions can have any signature. Only the composition function uses `half4 FuncName(Varyings input)`.");
                    break;
                case PlanPhaseType.MultiPass:
                    sb.AppendLine("TARGET: Generate ADDITIONAL PASSES (NOT the main pass) as described in the MultiPass phase.");
                    sb.AppendLine("Use `// [AILab_Pass: name=\"...\" lightmode=\"...\"]` tag for each new pass.");
                    sb.AppendLine("Each pass needs its own vertex + fragment blocks. Follow the same signature rules.");
                    break;
                case PlanPhaseType.Textures:
                    sb.AppendLine("TARGET: Generate AILab_Property declarations for all textures described in the Textures phase.");
                    sb.AppendLine("Output ONLY the property declarations, no function blocks.");
                    break;
            }

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Passes: {FormatPasses(doc)}");
            }

            return sb.ToString();
        }

        public static string BuildPlanExecutionUserPrompt(ShaderPlan plan, PlanPhaseType targetPhase)
        {
            var phase = plan.FindPhaseByType(targetPhase);
            if (phase == null)
                return $"Execute the {ShaderPlan.GetPhaseTypeLabel(targetPhase)} phase.\n\nOUTPUT FORMAT: Return ONLY the HLSL code with AILab tags. Wrap in ```hlsl code blocks.";

            var sb = new StringBuilder();
            sb.AppendLine($"Execute the {phase.Title} phase:");
            sb.AppendLine();
            sb.AppendLine(phase.LLMProposal);
            sb.AppendLine();

            if (phase.Items != null && phase.Items.Count > 0)
            {
                sb.AppendLine("Required items:");
                foreach (var item in phase.Items)
                {
                    if (item.IsConfirmed || phase.Status == PhaseStatus.Confirmed)
                        sb.AppendLine($"- {item.Key}: {item.Description} ({item.Detail})");
                }
            }

            if (!string.IsNullOrEmpty(phase.UserResponse))
                sb.AppendLine($"\nUser notes: {phase.UserResponse}");

            sb.AppendLine();
            sb.AppendLine("OUTPUT FORMAT: Return ONLY the HLSL code with AILab tags. Wrap in ```hlsl code blocks.");

            return sb.ToString();
        }

        // ---- Combined Main Pass Execution (Vertex + Fragment in one call) ----

        public static string BuildMainPassExecutionSystemPrompt(ShaderPlan plan, ShaderDocument doc)
        {
            var sb = new StringBuilder(CoreSystemPrompt);

            sb.AppendLine();
            sb.AppendLine();
            sb.AppendLine("=== MAIN PASS CODE GENERATION ===");
            sb.AppendLine("Generate the COMPLETE code for the shader's main rendering pass (both vertex and fragment logic) in a SINGLE response.");
            sb.AppendLine();
            sb.AppendLine($"ORIGINAL USER REQUEST: {plan.UserRequest}");
            sb.AppendLine();
            sb.AppendLine("CONFIRMED PLAN PHASES:");

            foreach (var phase in plan.Phases)
            {
                if (!phase.IsTerminal) continue;
                sb.AppendLine($"\n--- {ShaderPlan.GetPhaseTypeLabel(phase.Type)} ---");
                sb.AppendLine(phase.LLMProposal);
                if (phase.Items != null)
                {
                    foreach (var item in phase.Items)
                    {
                        if (item.IsConfirmed || phase.Status == PhaseStatus.Confirmed)
                            sb.AppendLine($"  * {item.Key}: {item.Description} - {item.Detail}");
                    }
                }
            }

            sb.AppendLine();
            sb.AppendLine("FRAMEWORK ARCHITECTURE — READ CAREFULLY:");
            sb.AppendLine();
            sb.AppendLine("The framework auto-generates vert() and frag() entry points. You MUST NOT generate vert() or frag().");
            sb.AppendLine("You produce modular BLOCKS that the framework wires together.");
            sb.AppendLine();
            sb.AppendLine("BLOCK STRUCTURE for the main pass:");
            sb.AppendLine("1. ONE vertex block (Section: \"Vertex\"):");
            sb.AppendLine("   - Signature: `void FuncName(inout float3 positionOS)` — exactly ONE param.");
            sb.AppendLine("   - The framework passes the object-space position. Modify it for displacement, etc.");
            sb.AppendLine("   - If no vertex displacement is needed, generate a simple pass-through.");
            sb.AppendLine();
            sb.AppendLine("2. Helper functions (Section: \"Helper Functions\"):");
            sb.AppendLine("   - Any utility/helper functions called by the main fragment function.");
            sb.AppendLine("   - Can have any signature (e.g., `half CalcShadow(Varyings input)`).");
            sb.AppendLine("   - These are NOT auto-called by the framework; they are only called by your composition function.");
            sb.AppendLine();
            sb.AppendLine("3. ONE final fragment block (Section: \"Fragment\"):");
            sb.AppendLine("   - Signature: `half4 FuncName(Varyings input)` — exactly ONE param.");
            sb.AppendLine("   - This is the ONLY function auto-called by the framework's frag().");
            sb.AppendLine("   - It should call your helper functions and return the final color.");
            sb.AppendLine();
            sb.AppendLine("AVAILABLE VARYINGS (from DataFlow):");
            if (doc?.ActivePass?.DataFlow != null)
            {
                foreach (var vf in doc.ActivePass.DataFlow.VaryingFields)
                {
                    if (vf.IsActive)
                        sb.AppendLine($"   - {vf.HLSLType} {vf.Name}");
                }
            }
            sb.AppendLine();
            sb.AppendLine("IMPORTANT:");
            sb.AppendLine("- Generate AT MOST 1 Vertex block + a few Helper blocks + 1 Fragment block.");
            sb.AppendLine("- If you need URP lighting (Light, GetMainLight, etc.), just use the API — the framework auto-adds includes.");
            sb.AppendLine("- Do NOT generate multiple Fragment-section blocks. Put helpers in Helper Functions section.");
            sb.AppendLine("- Wrap code in ```hlsl blocks with proper AILab tags.");

            if (doc != null)
            {
                sb.AppendLine();
                sb.AppendLine("CURRENT SHADER CONTEXT:");
                sb.AppendLine($"- Shader name: {doc.ShaderName}");
                sb.AppendLine($"- Existing properties: {FormatProperties(doc)}");
                sb.AppendLine($"- Passes: {FormatPasses(doc)}");
            }

            return sb.ToString();
        }

        public static string BuildMainPassExecutionUserPrompt(ShaderPlan plan)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Generate the COMPLETE main pass code (vertex + helpers + fragment) in ONE response.");
            sb.AppendLine();

            var vertPhase = plan.FindPhaseByType(PlanPhaseType.VertexShader);
            if (vertPhase != null && vertPhase.Status != PhaseStatus.Skipped)
            {
                sb.AppendLine("=== Vertex Requirements ===");
                sb.AppendLine(vertPhase.LLMProposal);
                if (vertPhase.Items != null)
                {
                    foreach (var item in vertPhase.Items)
                    {
                        if (item.IsConfirmed || vertPhase.Status == PhaseStatus.Confirmed)
                            sb.AppendLine($"- {item.Key}: {item.Description} ({item.Detail})");
                    }
                }
                if (!string.IsNullOrEmpty(vertPhase.UserResponse))
                    sb.AppendLine($"User notes: {vertPhase.UserResponse}");
                sb.AppendLine();
            }

            var fragPhase = plan.FindPhaseByType(PlanPhaseType.FragmentShader);
            if (fragPhase != null && fragPhase.Status != PhaseStatus.Skipped)
            {
                sb.AppendLine("=== Fragment Requirements ===");
                sb.AppendLine(fragPhase.LLMProposal);
                if (fragPhase.Items != null)
                {
                    foreach (var item in fragPhase.Items)
                    {
                        if (item.IsConfirmed || fragPhase.Status == PhaseStatus.Confirmed)
                            sb.AppendLine($"- {item.Key}: {item.Description} ({item.Detail})");
                    }
                }
                if (!string.IsNullOrEmpty(fragPhase.UserResponse))
                    sb.AppendLine($"User notes: {fragPhase.UserResponse}");
                sb.AppendLine();
            }

            sb.AppendLine("OUTPUT: Return 1 Vertex block + Helper blocks + 1 Fragment block. Use ```hlsl with AILab tags.");

            return sb.ToString();
        }

        // ---- Plan Response Parsing ----

        public static List<PlanPhase> ParsePlanDecompositionResponse(string response)
        {
            var phases = new List<PlanPhase>();
            if (string.IsNullOrEmpty(response)) return phases;

            string json = ExtractJsonFromResponse(response);
            if (string.IsNullOrEmpty(json)) return phases;

            var phasesArrayMatch = Regex.Match(json,
                @"""phases""\s*:\s*\[([\s\S]*)\]",
                RegexOptions.Singleline);
            if (!phasesArrayMatch.Success) return phases;

            string phasesBody = phasesArrayMatch.Groups[1].Value;
            var phaseBlocks = SplitJsonArrayElements(phasesBody);

            foreach (string phaseJson in phaseBlocks)
            {
                var phase = ParseSinglePhaseJson(phaseJson);
                if (phase != null)
                    phases.Add(phase);
            }

            return phases;
        }

        public static PlanPhase ParsePhaseRefinementResponse(string response)
        {
            if (string.IsNullOrEmpty(response)) return null;
            string json = ExtractJsonFromResponse(response);
            if (string.IsNullOrEmpty(json)) return null;
            return ParseSinglePhaseJson(json);
        }

        static PlanPhase ParseSinglePhaseJson(string json)
        {
            var phase = new PlanPhase();
            phase.Status = PhaseStatus.WaitingForUser;

            var typeMatch = Regex.Match(json, @"""type""\s*:\s*""([^""]+)""");
            if (typeMatch.Success)
                phase.Type = ParsePhaseType(typeMatch.Groups[1].Value);

            var titleMatch = Regex.Match(json, @"""title""\s*:\s*""([^""]+)""");
            if (titleMatch.Success)
                phase.Title = titleMatch.Groups[1].Value;
            else
                phase.Title = ShaderPlan.GetPhaseTypeLabel(phase.Type);

            var proposalMatch = Regex.Match(json, @"""proposal""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (proposalMatch.Success)
                phase.LLMProposal = UnescapeJsonString(proposalMatch.Groups[1].Value);

            var questionMatch = Regex.Match(json, @"""question""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (questionMatch.Success)
            {
                string q = UnescapeJsonString(questionMatch.Groups[1].Value).Trim();
                if (!string.IsNullOrEmpty(q))
                    phase.LLMQuestion = q;
            }

            var itemsMatch = Regex.Match(json, @"""items""\s*:\s*\[([\s\S]*?)\]", RegexOptions.Singleline);
            if (itemsMatch.Success)
            {
                var itemBlocks = SplitJsonArrayElements(itemsMatch.Groups[1].Value);
                foreach (string itemJson in itemBlocks)
                {
                    var item = ParseSingleItemJson(itemJson);
                    if (item != null)
                        phase.Items.Add(item);
                }
            }

            return phase;
        }

        static PlanItem ParseSingleItemJson(string json)
        {
            var item = new PlanItem();

            var keyMatch = Regex.Match(json, @"""key""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (keyMatch.Success)
                item.Key = UnescapeJsonString(keyMatch.Groups[1].Value);

            var descMatch = Regex.Match(json, @"""description""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (descMatch.Success)
                item.Description = UnescapeJsonString(descMatch.Groups[1].Value);

            var detailMatch = Regex.Match(json, @"""detail""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (detailMatch.Success)
                item.Detail = UnescapeJsonString(detailMatch.Groups[1].Value);

            var catMatch = Regex.Match(json, @"""category""\s*:\s*""((?:[^""\\]|\\.)*)""");
            if (catMatch.Success)
                item.Category = UnescapeJsonString(catMatch.Groups[1].Value);

            if (string.IsNullOrEmpty(item.Key) && string.IsNullOrEmpty(item.Description))
                return null;

            return item;
        }

        static string ExtractJsonFromResponse(string response)
        {
            var codeMatch = ReCodeBlock.Match(response);
            string text = codeMatch.Success ? codeMatch.Groups[1].Value : response;

            int firstBrace = text.IndexOf('{');
            int lastBrace = text.LastIndexOf('}');
            if (firstBrace >= 0 && lastBrace > firstBrace)
                return text.Substring(firstBrace, lastBrace - firstBrace + 1);

            return text;
        }

        static List<string> SplitJsonArrayElements(string arrayBody)
        {
            var elements = new List<string>();
            int depth = 0;
            int start = -1;

            for (int i = 0; i < arrayBody.Length; i++)
            {
                char c = arrayBody[i];
                if (c == '{')
                {
                    if (depth == 0) start = i;
                    depth++;
                }
                else if (c == '}')
                {
                    depth--;
                    if (depth == 0 && start >= 0)
                    {
                        elements.Add(arrayBody.Substring(start, i - start + 1));
                        start = -1;
                    }
                }
            }

            return elements;
        }

        static PlanPhaseType ParsePhaseType(string raw)
        {
            switch (raw)
            {
                case "VisualAnalysis": return PlanPhaseType.VisualAnalysis;
                case "DataFlow":      return PlanPhaseType.DataFlow;
                case "Textures":      return PlanPhaseType.Textures;
                case "VertexShader":   return PlanPhaseType.VertexShader;
                case "FragmentShader": return PlanPhaseType.FragmentShader;
                case "ShaderOptions":  return PlanPhaseType.ShaderOptions;
                case "MultiPass":      return PlanPhaseType.MultiPass;
                default:               return PlanPhaseType.VisualAnalysis;
            }
        }

        static string UnescapeJsonString(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return s.Replace("\\n", "\n")
                    .Replace("\\t", "\t")
                    .Replace("\\\"", "\"")
                    .Replace("\\\\", "\\");
        }

        static string Truncate(string text, int maxLen)
        {
            if (string.IsNullOrEmpty(text)) return "";
            return text.Length <= maxLen ? text : text.Substring(0, maxLen) + "...";
        }
    }
}
